/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 16);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
// replace this with 'http://localhost:8000' to test locally
// use 'https://trampolinedraak.herokuapp.com' for production
var serverInfo = {
  SERVER_IP: 'http://localhost:8000', /* 'https://in-the-same-boat.herokuapp.com', */
  socket: null,
  server: null,
  roomCode: '',
  vip: false,
  playerCount: -1,

  timer: 0,

  turnCount: 1,
  dayTime: true,

  language: 'en',

  health: 100,

  roleStats: [{ lvl: 0 }, { lvl: 0 }, { lvl: 0 }, { lvl: 0 }, { lvl: 0 }],

  // These variables are for the player interface only
  // They keep track of what you've already done/seen/activated
  submittedPreparation: {},
  submittedUpgrade: {},
  errorMessages: [[8, 0]], // each game starts with the messages "the game has started, good luck!"

  // Backup ship drawing, in case preparation is skipped
  backupShipDrawing: "data:image/png;base64,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",
  backupMonsterDrawing: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAU8AAAFPCAYAAADNzUzyAAAeGElEQVR4nO3dfaxlVXkG8NMotnUsVDCVkmCxkZYqH7YU01gstqJkMEYFJRGSigmptKkNsUWE0kpR+RJUPlRGHamXuffs93n3vc4IGYq23vKNdkAsFKpSwVAECjMM8uHwNU//OHdg7nzcu9Y+e+9333OeX7IT/uCe86xz1n5nnbXX3qvXExERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERkdFF4O0EriVwH4FHCZR0Py46l4hIZ9H9EwS4k+MxAiu4du2u0TlFRDqDZkcvUDi3PjbTbBXNjozOLCISjkCZWDy3Pu6l2Vksiv2j84uIhJib38wtnlsf6+l+SnQ7RERaNXeBaJjiOTjcb41ui4hIa+ausA9fPAcF9A4Wxe9Et0lEpHFzS5TqKZ6D41G6HxXdrlFG4BUEXsN+//fp/ja6v5/uH6b7qTQ7n2ZfI7CawLV0v5fAJrpvrvl7JoHnafYY3Wdpdjrdj2JZ7hf9+Yi0ZpGlSlVHoZ+IbteoYFm+gWarCDxM4PkGimDdx9MEvk+zKRVVGXk0O5pmD9Z8EpUEdotu21JEsz+h2bkE7uhAMazrH9TNBB6g2Re4bt0u0Z+xSK0InD03wqnnhDH7IYFDo9vVdQReRuC9BL5K4IHwQtf88TTdL2FRHBL92YvUikWxP83OInBvTUX0K9Ft6hpefvlvsihOoNk3aPZMBwpa1LGBRfH30d+HSO1odiTNVtVw0eFOluWB0e2JRuBTBB7qQNHq2rEu+rsRaQTXrt2V7lNDnySDEe1LotvTNrq/mWZ3d6BIdfmYif6eRBpD4NC5ucxhTpKnaHZWdFvawDVr9iKwogOFaakcF0R/ZyKNIbAbq90Xv+1xfXRbmkT3Uwls6kBBWmqHCqiMtprWiN7MEVvSRLNzCDzegSK0lA8VUBltdD+Kwz5gxOx2Am+MbsuwODv7UgLfa6GwPM3BSohrCaym2ddodj7dT5272+j9dH8b+/3fJ/AaAq+ova1luR/dj6LZ6TSbIvD9uVx1tnO67twincKi+B0Ctw95ojxOs/dEt6Uqmv0xgZ80UizNnqHZN1gUJ/Dyy38zuq0LmVdUgVkCTwzZfl2Fl9FHs5uGLhTul0a3IxeBjzZQNB/gYNH8ewm8LLqNw2BRHEL3S4ZYz6oRqIw+up9F4KkhC8cN0e1IQWB3mlmNBfMOmp1Lsz+JblsTuG7dLgS+VfGz0RyojD4CL5lbzzlMIbkyuh0LYVEsJ3BPDQXzKZr1WZZviG5TWwhcUOmzctcIVMYDy/JAAv89RGHp5MlS0yqDTXQ/NbotUSoXUM2Byjih+z8PUWQ683ON09O/Rfe1NRTOFVyzZq/o9kQbooDqXngZHzR7D6uvffxueP6yPIbA+iGL5o/o/ubotnQJgekKn+OG6NwirSLwxrk1nVUKz8cDc1cdIW05NtP9hKj8XVfp8zX74+jcIq3i4NbOakua3C9sOesBBK4fsnBeT+CANnMvRdkjUPeV0ZlFQhC4tWIxOrilfBcQGPYxfJ2Zr10KskegU1Ovis5cN/b7+3DwIJn1XHzbldui80oQAl7h59rdjecyG3a0uZ5leUzTOUcRgaszRp8fi85bB/b7+9D9JALXVOhrz0bnlyDZP9cGx80NZXkZ3W8eqnC6r+X09G81kW9cMH0rmP+OzlrVkAVTI1AZILCuQoc5r+YMr+XgCU/DFE7tGloDup+b/JkXxbuj86bixMQyun+WwIYaCubW/W5zdNskEIHrKnScp1mWE0O/t/tb6H7fEB34HhbF8jo+B+n1ODW1X0bhWB2ddzEE/ozuKwk8V2vR3OqIbqMEo/sPKnaehyq/p9kHhuq4g3vbd6/zc5Bej+6rk7+DqanO7QvPfn/vuUcEtrJ9dHR7pQPo/qNKHajCCJTufzdkp/1oE5+B9HosindnjD7Pjc67BYH3EUgv/HUc+tkuvV6vR+Dgih1oU+b7fH6IznqvFmk3j+nPRXgyNOfMzEF0/wwHjxFsr2i+eOiCkQzQ/ZIqnSjptYGXcbj9l27h7OxLm/4MpNej+8eSvxez81vNtnbtrjS7kMPuojD8oaVKMh8H2zrUWjw57BV19y+30XYZ4NTUqzK+n/9rJZPZkTRbFVwwtxwaccr2COxJ4NmMwrbgz/ahr6ibfaCttsuL5q5Sp31HMzN7NJKhKPafez7tvS0WxmvofhL7/X2aaJOMOLqfn9zZFrhgNNQVdff76P6WNtstL5rbGyrkHzgCZzN9wb4KpnQLzVLWf+50qdKQzxK9mcBr22yvbI/AY4nf12W1vJ/7cTR7sKWCuZHuX1LBlEbQ/QwOrmTOf1CH+6YFR5zAvw/RqUsu8Y3XRgXNvp74nd0/1PsMiuYtLRTMB+j+Gc7MHFTXZyRSG7pfPkTn/nx0fnkRgTdlfHdvyn799ormagLva+IzEqkFy/KDlTu4+99F55ftEbg/8fs7PeM1P0VgY6MF0/0Oup/Kfn/vJj8fkaGxLI+o3NF1Rb2zCFyW+D1em/R6ZtUeyJ12PDe3SuDPmv5cRGoxd6dH/qJlXVHvvKwVE4ssWaL7aQ0VzQ0EPs+JiWVtfS4iQ+OaNa+m+10VOryuqC8BnJnZo65fEASeqbFg3kuzs1gU+7f1WYjUiu6zFTr+tdQV9SVj7vtK+V4XXLI0dMF030yzVTQ7sq22izSCwI0VToBbo3NLHrqfnvj9LrhkaYjC+XMCK7h27a5ttVmkMay2u+V3onNLPta0ZCm7v5jdQvfj2myrSKPmtjTIHXHORueW6pi6ZGmBn+50T9sVVUVTRhGrPPfT/S6uWfPq6OxSHdOXLG1c4DVuS/j7n7bZLpHWMHfTOPdHdTvc0pe1ZGmBK+Bc+IldekamjCYCK7JHnWV5RHRuGV7mkqWzFnwt4LZ5P+EH/61nZMpoIvAXFQrnB6NzS30IPJL43d8bnVWkEyrNc5qtjM4t9WLO/lNaiylSYZ7T7JbozFI/rl27a8YV81XReUVCVZjnvDs6szQnYx+hzVrULmOr0jwncHB0bmkOzY7M6AsrovOKtK7SPCfwF9G5pXlM35DtweisIq3LnufUKGNszO1ouXifcN8cnVWkVRXmOddFZ5b2sCj2T+4bZblvdF6RVmieU1IQeCKpb5i9KzqrSOM0zympCFyT2D9Ojs4q0jgCP9Y8p6Sg+5mJI0/dLCGjje43a55TUhE4NrGfXB+dVaQxdD9H85ySI2OK55HorCKN4OzsrxB4SvOckoMTE8sy+sue0XlFakezz2meU6ogcE9Sn3F/a3RWkVoROFTznFIVgasSLxqdGJ1VpFYErtM8p1RF97RfLe6fi84qUhu6n5RVOM0ujc4s3UKzExP7z1XRWUVqwX5/78yLRHdEZ5buoftbE/vPPdFZRWqR8UzGwTE1tV90ZukeAnsm96GJiWXReUWGQuC9mT/XT4vOLN3F9H2NNF8uSxvd78oontpOQxZE4PrEvnRsdFaRymj26cxRp7YNlgXRbGVSX3I/MzqrSCUsij/IKpxaDC8JCJyc+A/xTdFZRSoh8C8ZhfMRzszsEZ1Zuo9m70rsUxujs4pkY/4Djkf63nWW5QTdN231k3ITy3IiOtdSxLLcN7VfRWcVycKZmT0yroiSwL9EZ24SgYcWaPtD0fmWouS+tXr13tFZRZIxdz+ioviD6MxNYVlOLNp+jUCzEfh5Yv86LDqrSBKaHZFVOM0+HZ25SfN+qu/scN8UnXOpIXBLUv9y/1B0VpEkyZ160LHvis7bNM3NNYPAxYl9TMuVpPtodlrWqBN4b3TmpnW1eC71C1gEPpr4y2ZVdFaRBXFqar/Mn+tj0am7+LOdI3ABi2bvSexrN0ZnFVkQgf/KKJ5Psd8fi6ugXbtg1LU8VbEsD0zsaw9EZxXZKZp9NmvU6X5SdOY2dWmk18WRcBVcufLXkvvbypW/Fp1XZIcIbMwontdF543QlTnG1O+p7VxVEHggqT1leWB0VpHtEPjLrFEncGh05nE2YsXzxqT2mL0nOqvIdgj8NLlwmmlfmWCj8rO918t6wPZHo7OKzEPg48mF0/1Jzs7+SnTmcTcqF4x6vV6P7mcm9r+Lo7OKvIDAbllznWZfiM4sA+zQBaxh0P1Dif3vu9FZRV5A4OyMeU5txtUxXbmANQwChyX2v8ejs4r0er1ej8BrMgonCbwzOrOMHq5evXdyH9RmcNIFBL6YUTivjM4ro4vumxPn3JdHZ5UxR+CAzFGnliZJY5j+3Nizo7PKmCMwmVE4J6PzymgjsDqxL94QnVXGGIFDM0edB0RnltFG9+Wa95TOI3BlRuH8YnReGX2cmFiW3Cc17ykRCLwzc9T5mujMMh4I3JDYJxGdVcYQ3e/LKJyanJfWMH3N8frorDJm6H5WRuHcSGC36MwyPrLmPWdnXxqdV8YIzR7OKJ4fj84r4yVr3nN6+o+i88qYYFEclFE4fxqdV8YTgUcTLxp9JDqrjAkC52UUz7+MzivjicCaxOL59eisMiYI3J9YOPXwBQlD4Pikfmp2Z3RWGQN0Pyp51On+4ei8Mr5Ylm9I7quTk6+MzisjjsB0Yod8jsArovPKeGPq82WL4h3RWWWEsd/fK2Ou87LovCIEvp340/206KwywgicnFw8zQ6PzivC9MXyM9FZZYQRuC2xI94VnVWk1+v1aHZ0Yp+9LzqrjCi6vyXjQtHp0XlFer3sHQ707AWpH80uzeiEr43OK7IFgbRnMJgdHZ1VRgxXrNiFwOOJhVNbbEinEJhJ7Lt6eI3Ui6mLjQf/en8gOq/I1mh2WmL//XZ0VhkxTF3uATwSnVVkWyyKdyT2343RWWWEsCz3y7hQdGF0XpFtcXLylcl9uCzfEJ1XRgTNPplxoehN0XlFdoRmdyb24eOjs8qIIPCTxE733eisIjtD968n9uNvRmeVEcCcPYrM/iY6r8jO0P0jiX15Q3RWGQF0n0ounjMze0TnFdkZTk//UXJfvuiiX47OK0sYZ2b2yLhQNBWdV2QhnJ19acbc/WHReWUJo9nfZHS2d0bnFVkMgfWJg4FTorPKEkbgu4mF8yfRWUVSMP1Oo9XRWWWJIvCmjAtFn4zOK5KCZsck9usHo7PKEkX3C5OLZ1nuF51XJAX7/b3Vr6VRBB5J7GS6F1iWFAL/kzjv+aHorLLE0OwDGReKjo/OK5KDwGRi314RnVWWGAJXJnaux7lixS7ReUVyEPjrxP79n9FZZQkh8NqMC0WXRucVycV+/w8zflntHp1Xlgi6n57csdzfEp1XpAqaPZF40ejI6KyyRBC4K7F43hadVaQqpm9HrGV4sjiaHZ7xc+bk6LwiVWU8ZlGrSWRxBC5LLp79/l7ReUWqYlkemTjyfCI6q3QcgVcQeC6xeE5H5xUZBoHdMwYKfxidVzqMZul3FLkfFZ1XZFgE/jOxz/91dFbpMAL/l9iR7o/OKlIHAisS+/xkdFbpKE5MLMu4UHRedF6ROtD9Q4l9/n+is0pH0X15cvEsioOi84rUIWtX2H5/7+i80kEEzk7sRI9FZxWpE4EHE6+6HxOdVTqIwA2JF4r60VlF6kRgdeLAYW10VumYrPlO9+XReUXqRPdTEvv+I9FZpWOy5jsnJpZF5xWpE4HDEvv/5uis0jEZ8503RGcVqRsvuuiXkwcPk5OvjM4rHZI83wmcHZ1VpAkEnko6B7Qth2yh+U6RXo/ADxPPA+3lLgOa7xTp9QhckTjy1HIlGdB8p0ivR+Crib++PhKdVTpC850ivR6BTyWeB5+KziodoPlOkQG6fyTxXPhqdFbpAM13igywLI9JPBeuiM4qHaD5TpEBpi+U/3F0VukAzXeKDGQ8XenJ6KwSTPOdIi/i5OQrU8+H6KwSTPOdIvMR2Jx0PpTlvtFZJZDmO0XmI7Ax6Zwwe1d0Vgmk+U6R+QjcnHhOnBydVYJovlNke3Q/M3HkuTI6qwTRfKfI9ggcm3heXB+dVYIQ+KbmO0XmI3Bw4nmhJ8qPKwKPaL5TZL7M7bf3jM4rAZi6JEPznTJmCNyTeG68NTqrtIxTU6/SfKfIjhG4KvGi0YnRWaVlBA5ILJ66DU3GDt0/lzjy/Fx0VmkZ3d+RWDz/KzqrSNtodmLi+XFVdFZpGYHjE3+WlNFZRdpG97cmFs97orNKy+h+auLPkouis4q0jcCeuiYgO0T3ixKL56nRWUUiMH0p38HRWaVFNCsTO8bx0VlFIhC4PvEcOTY6q7SIwJ2JI893RGcViUCzlYnnyJnRWaVFBJ5M/Ff1gOisIhEInJx4jtwYnVVaRPe0u4umpl4VnVUkAs3elVg8N0ZnlRalXkmMzikShWW5b+J5sjk6q7RIxVNkcannCa+44uXRWaUlKp4iiyOwKelcWbNmr+is0hIVT5HFEfhZ4rny+uis0hIVT5HF0ex7SeeK+5ujs0pLVDxFFkfgW0nnitmR0VmlJSqeIosjgMRzRXcZjQsVT5HF0f3LiT/b/yo6q7RExVNkcQTOS/zZflp0VmmJiqfI4mh2WuK5cl50VmmJiqfI4uj+V4k/278cnVVaouIpsjgCxyaeK4jOKi0Z1+JJszMIPMBtt10ePChlA93PiM4o3UGzIxPPlW9FZ5WWjFvxJLAn3e9KbPd10XmbxnXrdqH7hXR/iMBzO/kcnqb7P0dnjUT3NydeMPpedFZpyTgVT5pdSuDZ1DbPjUQ/EZ27CSyKQ+h+Cc2eyfg8fhadOwqB1ycWz/ujs0pLMorIZ6KzVkWzTxP4RVbRfPF4IDp/nQj8I9P35NlRP+hHtyEC16zZK/Ezejo6q7SEwPOj/C8qU2+rW/h4SXQ7hsXBLpCp0xULHc9EtyUCr7ji5amfUXRWaQndU58Ws+SKCM3OqaFYkEVxSHRbhkGzc+meN12x8OjzuOg2RVDxlHmYeufEEisicyOFtGcwLt7uD0e3pyoC19VWNLccZrdEtyuCiqdsh6kXUZZQEaFZ2n70acdV0e2pgu7X1l44x3j0qeIp22H6vOCV0VlT0OxPax5pPRHdphxcs+bVdJ9trHCO6ehTxVO2w6L4cGLH+I/orCkI3NxAwXh7dLtScGbmoIx1rBp9ZlDxlO2wKA7JOGlmovMuhGanNFQspqPbthiW5RF0f7SVwjk4RmoZ12JUPGU7BF6SedI8FJ15R1iW+ybvQw9wboH448n/f1HsH93GnWFZfnCoQui+ie6XsCgOodktGX97dnTb26LiKTtE4OGsk60sJ6Izb4vuP8pow+a5YvvZjL+5OLqNO0Kzrw9ROJ+l+0quW7fLC6/nflzG3z8c2fY2qXjKDiU/KfvFo1OLpWn2zaz8Zqe88LdA6k/dZwnsHtnObRGofkXd7HYCe+7wdXNGn0Xxe223O0LGr5rdorNKi9jv75N78kVn3oLABZnZb5739+6nJv+t+6lR7dwWgcnKhXORB31kjT7NzminxbFolnqL7+uis0rLKpyA4VdbKxRO0uxPt3mN3Zn+wJBHo9q6NZbliZULZ1l+MOk9gJ8n9oO7mm5vFxC4O+nz6Pe1/fC44bbPtly8CD0YnLdK4bxoJ691ccY/Gp9tu63zsrq/v1LRdH+UZXlE8vuYfSXj9Q9rss1dQODqxM/53dFZpWUEHqxwQoY8balS4QR+wSuuePkOX68o9s94nbBHs7Hff1vFwnkXZ2YOynqvmZk9Mt7ji021uStotirxsz4hOqu0jO7/UOHEXN96zmqFk3Q/d5HXnc54vdYfkkLgjQTWV2j3LNeseXXF9yy72g/alrwyo0Pz4tIiArdWKEyt3X0zROH8WMJrvz359Vp+SAr7/b0J5CzF2nLMDvW+wPsy3ut9dbW3i5IvLAZP60iguRHoxoyTppW7bwhcUalwZtwVxdRF8y0+JGXuCVE3VWj3rbW8f/pot6zj/bqK7ickfQ5mq6KzSrCsAtrw3Td0v6Fi4bwg632AqxJf99+aausOMl1Zod21bURG4IvJ7zszs0dd79s1dH934udwdXRWCcacK9AN3n1DYEUbhbPXy3hIitkvmmjrdnmqPY+z1qdfETgs+b3dL6zzvbuE/X7aJnDA3dFZpQOYPvps5O4bluXRbRXOXi/zISlmf1t3e+dlAaqMtm/a2YqCobKkP6mpE+tgm0DgdV36h1U6LvLum7lCVmXjtkqFs9fLfkjKBl522a/X2eatcuSM+rccP2K/v3cjeQb73Kfl6Pf3aSJDNAK7JZ4Hm6OzSgcw6O4bzsz8Bs1+2GbhfOG9gf/N+Aej9nWunJ4+vEK71xN4Y91ZXshUFL+X8Zmc1FSOaKmfQXRO6YisUZD7pTW9Z5VdL4cunHPvnb6vE0CW5X51vG+v98KSpPTi/eJo7211ZdhptvQpnGuazhJFxVOyZN598ySHXECeeVvglsPram+vl3EfM1Dr0hQCt2W33f39db3/ItnSr7qP7k93FU/Jw5y7b8zOqvw+7qdXKJy1rGeclyN3H6RtHjZS6T2BG7PbXpYn1tHepHw5T95y/1Jbudqk4inZmHP3zeCkPjD7PYrizysUzhubaG+vl3Ev8+D4yVDvBZyd3Xazr9XV1oyc1yTmG8nbNVU8pRK6P5Jxct+Z9do5awlfHN3cyquvXtZYe8tyv8xMn6/0PqtW7crcPebdQzbjo/tJyRknJhr7bnq9Xo8TE8vovpwAaLaBwPM7+aw2E7itlvdU8ZQqKoyOkp60M/dz8L7M115P4PWNt9n9MxmZNlR8jy9ltv0HdbczOWveT/fltb2n2eE0O5Fm59PsRqY+a3T+8ezQWVQ8pSoCP87orM8R+N0FX4/8JQLXZ58INZ2Yi7b3sst+ncCGjFxZD4hmUSzPbPv/NrWWMzlz+uL9ypvD0ewLBO7P2tAv7RhqBKriKZWxLA/M7KzfXvD1qmwlYdbaRZJer9ej2d9mZLsl67Xdf5DV9unpw5tqZ0bmqcS8N2S9LrD73E0ZzW2fPOQCdhVPGQrNzsosdmfs8HWqXCQJ2uqWwGMZJ2jS6JNmn8w88b/cdDtTzM0zpmVOmPecWwp3MdNvxhjqGKrtKp4yDA5uYXwys9POe+YnzarswTMZ1ua8DdEWHX1m3UM/OG5vo50pODGxLKPg73R6hYMVHDkPoFbxlKWP7udkdVqz+wn86tzf5s7zkcD1JH8ptM2DNqQWjQVHnwS+k9H2Zzg5+dtttTMF0+c9i+3+dnARLv+J+HUc+tkuXUDgPzI77/cIvL7CiXNfF+5YyRp9LrDPEYsifbkPQBZF5+4VZ+qUi9kLKxDofhzN8vfJqvcY9oJRygUsPRhEFkbgV+meu8TooQodvjM7M9LsluTc7tvdacXJyd8m8ExG278T0c7FZP56WEOzJ4KLJlnHUiX3f0v43lt7ULYsYcy98yj3KIo/j27j1jJHnw9v9/dA3pOiWt4rKVXWvGf0UeMi+V6v1+PC8/1P1vU+MgaynvWY1+lPj27bjmSNPrcqfgTWZLXf7JOR7VwMc9a/NndsJvAIgW/QfXnTdzW90PbBCHTrO5qe14hTKiHw7VpPCrOvRLdpZzJHn88RmMx+UpR72F1EqQgULRbJpwjcNHeH0Yk0O7wL8+AiQyPwu3OFoo4TpbbNy5rC1F02qx5F0codVMOouGoi95hmi1tbi4Sg2YVDnyxmP+TMzG9Et2UxBC5rrGAskce5NTjv+SyBi5vekVWkUwh8f4iT5hddvUCyrawHZOQdm7hq1a7R7UvFtKU7qcfGudsza99IUKTzCOzJqrfZleXR0flz0OwbDYw6z41uVw7Wcx/6Rja4dbXIkkH38yucQOuic+eq+NT7nR9mH4tuUy66/8MQ7b0/9ylUIiOPwLUZJ9ET0XmrIvCvNRXPmei2VEXg1szR9c9odk50bpHOIvBPBB7gzufFnucI7LTI4Z8IVMuun5HmRqCPbvddDxaoP053a3MdpogsERzM9d4+TiNOEZHaEPh7pj5mLfPBySIiI29uKdMKDp4gNf82PuChrt56KiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIi4+z/AVNboFdnTkTGAAAAAElFTkSuQmCC",
  dockDrawing: "data:image/png;base64,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Dc+yQ/CRqM+F0HMf+Yjx+p4GUP10inaJKAeGp0wgbouNzVi9es8KxpvsN1YiymEWh+dqiByG2KXoVC9LMlbfb53PpGiTiHKCY3GMkvtV+Nlmo5FzmbssOzz3OL2/dfJynah6cO7PU3LfigzOf+i2MQfxq8Y/kmicTzuCM9m780QUyXPGOUbheRdmLFSca5GQEC5IMEbvPkl8IJ6oalDdNsvCc/Uu45+fo651ucfnb39z3jaJKIGY0Kh7//qUxxHC2T3qj19hSXVugvE97GyTv3US1cHYh2cIt/QLuZw7gG5JND77SwD8rZOoPiJC47GS++f+WWFYaO6oO+cOoInG52mTv3US1UVEaKwstX+q33D2b631choh3Dky4ck9iojqxR0aqsdV0MdNhr49DccCGRC5O09wVnDmeU6K9ogoEVdghHBJZf3snIHu/Ptg50mBtd7L2YjFNwoJT4TwgzKDmogSqvMZZ1GQZt/3h3L1QfXCss9yiSih2Xjw5g5O1Vz7BaHzRpM9wEPYmmrsRJQIw9NZQng4QfuPOtvN/TA+ESXG8HSV9bnbVr0q4kx3XopxE1FCDM9yf3eEyGZnu9Mp2iWixGZpeHpfyUyzxUazub+z3RtTtEtEBZiN4dlomBZEWQnV05O2KbLEEZy/SNk2ESU2W8Oz0ei7KMdjaDb3L6i9jcb53gaROUX0gYgSmc3hWSaoznWcdV5XdX+JaAiGZzng2RWzoDNfIkqI4Vk8+N6jb1XdXyIycBzUq6ru6yiCyMcdcwyonlt1n4nIAL71MrlPuBNEHnPM79qq+0tERuisSuQ5M7qr6j6PCmTZ4c65zb2tBxGVBCILXAd4pzBAh4DIYvgW/3ii6j4TkRP8rwzyEn4AiFzrnk9u7EY0ehDCpyPCkzeReohcaPmrVfebiCJB5MbIAF3H3+p+AyKPuOeQz3USjTaItCID1LRb5biLWPgDCGF51f0mogQg0o4O0E7ZgBBm5bOKELkuIjznV91vIkokQYACImswSxa36J5x+oNT5Nqq+05EiSUK0C1Q/XzVYykKVE+H7yH4TlF9BiKLq+4/ERUkUYACIg+M2++hELkpej6y7PCq+09EBUMI8TeRdv99byxuKqHVOifHPPDxLqLZAqpnJgvQEQ9RiBwGkS05xv/xqsdARCWC6qcRwhOJQ/TXCOH7CGEhQvgAQjimbs88YnJyb6geBxGByKZc41U9u+rxEFFFoDoXIdySNER3L9sg8kuoXll2mM4IywwhrE84pv8ocxxEVFPdbSUeKDhEt5+xPQmRryDLTumuVLRHAeM5H6q+FaYYnEQUCyF8ASLPlBKio1m+W/V3REQ1BZE56DwUX3VQ1ancA94cIiILqJ4LkQ01CK6qy81VfxdENIJKuqlUzxLCoqrnn4hG3CwL0bshcljVc05EY6Qbog/WIOCKKmuqnmMiGmMIYRFU769B2KUo29D5ffeMqueViGYRNJv7I4Rjum8WLYTIDRD5YQ1CsV9ZD5EMqsdhcnLvquePiGgnaDb3h+oXEbOdRdqyBSLTDEsiGjkQ2QNZdjiy7BSoroLqBohsLTAwt6Kzj/2CqsdORERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERFQf/x+FSZEicYLMhwAAAABJRU5ErkJggg=="

  // language/translator object
  // serverInfo gets the language used in-game from the server, and also provides the translate function
  // not the cleanest approach ...
};var LANG = {};

// english
LANG['en'] = {
  'room': 'room',

  'game-waiting-1': 'Players can now join the game!',
  'game-suggestions-1': "Look at your screen. Fill in the suggestions and submit!",
  'game-drawing-1': "Draw the suggestion shown on your screen!",
  'game-guessing-1': "What do you think this drawing represents?",
  'game-guessing-pick-1': "Hmm, which one is the correct title?",
  'game-guessing-results-1': "Let's see how you did!",
  'game-over-1': "Final scores",

  'game-paused': "Game paused",
  'player': 'Player',
  'score': 'Score',
  'succesful-rejoin': "Succesfully rejoined the room!",
  'player-already-done': "You already did your job for this game phase, so you can relax.",
  'submit-guess': 'Submit guess',
  'guess-placeholder': "your guess ...",

  'vip-message-waiting': "You are VIP. Start the game when you're ready.",
  'start-game': "Start game",
  'submit-drawing': "Submit drawing",
  'submit': 'Submit',
  'controller-waiting-1': "Draw yourself a profile pic!",
  'controller-waiting-2': 'Waiting for game to start ...',

  'controller-suggestions-1': "Please give me a noun, verb, adjective and adverbial clause (in that order)",
  'controller-suggestions-noun': "noun (e.g. elephant, tables, etc.)",
  'controller-suggestions-verb': "verb with -ing (e.g. swimming)",
  'controller-suggestions-adjective': "adjective (e.g. beautiful)",
  'controller-suggestions-adverb': "adverb (e.g. carefully, to the beach, while sleeping, etc.)",
  'controller-suggestions-2': 'Thanks for your suggestions!',

  'controller-drawing-1': "Draw this",
  'controller-drawing-2': "That drawing is ... let's say, something special.",

  'controller-guessing-1': "This is your drawing. I hope you're happy with yourself.",
  'controller-guessing-2': 'What do you think this drawing means?',
  'guess-already-exists': "Oh no! Your guess already exists (or you guessed the correct title immediately)! Try something else.",
  'controller-guessing-3': "Wow ... you're so creative!",

  'controller-guessing-pick-1': "Still your drawing. Sit back and relax.",
  'controller-guessing-pick-2': "Which of these do you think is the correct title?",
  'controller-guessing-pick-3': "Really? You think it's that?!",

  'go-game-over': "Go to game over",
  'load-next-drawing': "Load next drawing!",
  'loading-next-screen': 'Loading next screen ...',

  "controller-guessing-results-1": "That was it for this round! At the game over screen, you can play another round or stop the game.",
  "controller-guessing-results-2": "Tap the button below whenever you want to start the next drawing",
  "controller-guessing-results-3": "That was it for this round! Please wait for the VIP to start the next round.",

  'controller-over-1': "Are you happy with your score? If not, TOO BAD.",
  'controller-over-2': "You can either start the next round (same room, same players, you keep your score), or end the game.",
  'start-next-round': "Start next round!",
  'destroy-game': "Destroy the game!",
  'continue-game': 'Continue game',

  'player-disconnect-1': "Oh no! Player(s) disconnected!",
  'player-disconnect-2': "You can wait until the player(s) rejoin. (To do so, they must rejoin the same room with the exact same name.) You can also continue without them, or stop the game completely."

  // dutch
};LANG['nl'] = {
  'room': 'kamercode',

  'game-waiting-1': 'Spelers kunnen zich nu aanmelden!',
  'game-suggestions-1': "Kijk op je scherm. Vul de suggesties in en klik op versturen!",
  'game-drawing-1': "Teken de suggestie die nu op je scherm verschijnt!",
  'game-guessing-1': "Wat denk jij dat de onderstaande tekening moet voorstellen?",
  'game-guessing-pick-1': "Hmm, welke van onderstaande titels is de juiste volgens jou?",
  'game-guessing-results-1': "Laten we eens kijken hoe iedereen het gedaan heeft ...",
  'game-over-1': 'Eindstand',

  'game-paused': 'Spel gepauzeerd',
  'player': 'Speler',
  'score': 'Score',
  'succesful-rejoin': "Rejoinen met de kamer was succesvol!",
  'player-already-done': "Je hebt je actie al gedaan voor deze spelfase, dus relax en wacht op de rest.",
  'submit-guess': 'Verstuur gok',
  'guess-placeholder': "jouw gok ..",

  'vip-message-waiting': "Jij bent de VIP (spelleider). Start het spel wanneer alle spelers gereed zijn.",
  'start-game': "Start het spel",
  'submit-drawing': "Verstuur tekening",
  'submit': 'Verstuur',
  'controller-waiting-1': "Teken een leuke profielfoto voor jezelf!",
  'controller-waiting-2': 'Aan het wachten todat de VIP het spel begint ...',

  'controller-suggestions-1': "Vul hieronder een zelfstandig naamwoord, werkwoord, bijvoeglijk naamwoord en bijzin in (op die volgorde)",
  'controller-suggestions-noun': "znw (olifant, tafels, etc.)",
  'controller-suggestions-verb': "ww op -de (zwemmende, springende, etc.)",
  'controller-suggestions-adjective': "bnw (mooie, domme, snelle, etc.)",
  'controller-suggestions-adverb': "bijzin (voorzichtig, naar het strand, etc.)",
  'controller-suggestions-2': 'Dank voor je suggesties!',

  'controller-drawing-1': 'Probeer dit te tekenen',
  'controller-drawing-2': "Die tekening is ... laten we zeggen, artistiek.",

  'controller-guessing-1': "Deze tekening heb jij gemaakt. Ik hoop dat je er blij mee bent.",
  'controller-guessing-2': 'Wat denk je dat deze tekening voorstelt?',
  'guess-already-exists': "Oh nee! Jouw gok is al door iemand anders gegokt, óf je hebt de juiste titel in één keer geraden. Probeer iets nieuws.",
  'controller-guessing-3': "Wow ... je bent zoooo creatief!",

  'controller-guessing-pick-1': "Dit is nog steeds jouw tekening. Leun achterover en relax.",
  'controller-guessing-pick-2': "Welke van deze titels is volgens jou de juiste?",
  'controller-guessing-pick-3': "... serieus? Je denkt dat dat de echte titel is?!",

  'go-game-over': "Ga naar game over",
  'load-next-drawing': "Laad de volgende tekening!",
  'loading-next-screen': 'Volgende scherm is aan het laden ...',

  "controller-guessing-results-1": "Dit is het eind van de ronde! Op het game over scherm kun jij kiezen om nog een ronde te spelen, of te stoppen.",
  "controller-guessing-results-2": "Klik op de knop hieronder wanneer je de volgende tekening wilt laden.",
  "controller-guessing-results-3": "Dit is het eind van deze ronde! Wacht aub totdat de VIP de volgende ronde begint.",

  'controller-over-1': "Ben je blij met je score? Zo ja, doe een dansje. Zo niet, JAMMER DAN.",
  'controller-over-2': "Je kunt de volgende ronde beginnen (zelfde kamer, zelfde spelers, score blijft behouden), óf het spel geheel eindigen",
  'start-next-round': "Start de volgende ronde!",
  'destroy-game': "Vernietig dit spel!",
  'continue-game': 'Ga door met het spel',

  'player-disconnect-1': "Oh nee! Een of meerdere speler(s) zijn hun verbinding verloren!",
  'player-disconnect-2': "Je kunt wachten tot alle spelers weer opnieuw verbonden zijn. (Om dat te doen, moeten ze exact dezelfde kamer met exact dezelfde gebruikersnaam joinen.) Je kunt ook kiezen om zonder hen verder te spelen, of het spel compleet te beëindigen."
};

serverInfo.translate = function (key) {
  var curlang = this.language;

  // if language doesn't exist, use english as default
  if (LANG[curlang] == undefined || LANG[curlang][key] == undefined) {
    curlang = 'en';
  }

  if (LANG[curlang][key] == undefined) {
    return ' <- string cannot be translated ->';
  } else {
    return LANG[curlang][key];
  }
};

exports.serverInfo = serverInfo;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var playerColors = exports.playerColors = ['#e6194b', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4', '#46f0f0', '#f032e6', '#bcf60c', '#fabebe', '#008080', '#e6beff', '#9a6324', '#800000', '#aaffc3', '#808000', '#ffd8b1', '#000075', '#808080', '#000000'];

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _loadPlayerVisuals = __webpack_require__(3);

var _loadPlayerVisuals2 = _interopRequireDefault(_loadPlayerVisuals);

var _colors = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var loadMainSockets = function loadMainSockets(socket, gm, serverInfo) {
  /***
  * MAIN SOCKETS
  * Some sockets are persistent across states
  * They are defined ONCE here, in the waiting area, and used throughout the game
  */

  // if a player is done -> show it by loading the player name + profile onscreen
  // do so in a circle (it works the best for any screen size AND any player count)
  socket.on('player-done', function (data) {
    console.log("Player done (" + data.name + ")");

    // offset the angle just a little bit, to make sure stuff doesn't clash
    var angle = (data.rank / serverInfo.playerCount + 0.25 * (1 / serverInfo.playerCount)) * 2 * Math.PI;
    var maxXHeight = gm.height * 0.5 / 1.3;
    var maxXWidth = gm.width * 0.5;
    var finalImageWidth = Math.min(maxXHeight, maxXWidth) * 0.66; // to make sure everything's visible and not too spaced out

    (0, _loadPlayerVisuals2.default)(gm, gm.width * 0.5 + Math.cos(angle) * finalImageWidth, gm.height * 0.5 + Math.sin(angle) * finalImageWidth * 1.3, _colors.playerColors[data.rank], data);
  });

  // go to next state
  // the server gives us (within data) the name of this next state
  socket.on('next-state', function (data) {
    // set the timer
    serverInfo.timer = data.timer;

    // start the next state
    gm.state.start('Game' + data.nextState);
  });

  // presignals always have the following format ['variable name', value]
  // they always set a variable on the server info (before a state change)
  socket.on('pre-signal', function (data) {
    for (var key in data) {
      serverInfo[key] = data[key];
    }
  });

  // force disconnect (because game has been stopped/removed)
  socket.on('force-disconnect', function (data) {
    socket.disconnect(true);
    window.location.reload(false);
  });

  /***
   * END MAIN SOCKETS
   */

  /***
   * PAUSING (main socket + pause message text object)
   */

  // This signal pauses/resumes the game
  socket.on('pause-resume-game', function (data) {
    if (data) {
      serverInfo.paused = true;

      var style = { font: "bold 32px Arial", fill: "#FF0000" };
      var text = gm.add.text(20, 20, serverInfo.translate('game-paused').toUpperCase(), style);
      text.anchor.setTo(0, 0);

      gm.pauseObject = text;
    } else {
      serverInfo.paused = false;

      if (gm.pauseObject != null) {
        gm.pauseObject.destroy();
      }
    }
  });
};

exports.default = loadMainSockets;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _dynamicLoadImage = __webpack_require__(4);

var _dynamicLoadImage2 = _interopRequireDefault(_dynamicLoadImage);

var _styles = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var loadPlayerVisuals = function loadPlayerVisuals(gm, x, y, color, data) {
  var newItem = gm.add.text(x, y, data.name, _styles.mainStyle.mainText(gm.width * 0.8, color));
  newItem.anchor.setTo(0, 0.5);

  if (data.profile != null) {
    var dataURI = data.profile;
    var imageName = 'profileImage' + data.name; // creates unique name by appending the username

    (0, _dynamicLoadImage2.default)(gm, { x: x - 100, y: y }, { width: 60, height: 78 }, imageName, dataURI);
  }
};

exports.default = loadPlayerVisuals;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _loadImageComplete = __webpack_require__(18);

var _loadImageComplete2 = _interopRequireDefault(_loadImageComplete);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var dynamicLoadImage = function dynamicLoadImage(gm, pos, dims, name, dataURI) {
  var doesKeyExist = gm.cache.checkKey(Phaser.Cache.IMAGE, name);
  if (!doesKeyExist) {
    // load the image; display once loaded
    var loader = new Phaser.Loader(gm);
    loader.image(name, dataURI + '');
    loader.onLoadComplete.addOnce(_loadImageComplete2.default, undefined, 0, gm, pos, dims, name);
    loader.start();
  } else {
    // if image was already in cache, just add the sprite (but don't load it again)
    (0, _loadImageComplete2.default)(gm, pos, dims, name);
  }
};

exports.default = dynamicLoadImage;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
var mainStyle = exports.mainStyle = {
	mainText: function mainText() {
		var wordWrapWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;
		var fill = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "#333";

		return { font: "Pirata One", fontSize: 26, fill: fill, wordWrap: true, wordWrapWidth: wordWrapWidth };
	},

	subText: function subText() {
		var wordWrapWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;
		var fill = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "#666";

		return { font: "Arial", fontSize: 12, fill: fill, wordWrap: true, wordWrapWidth: wordWrapWidth };
	},

	timerText: function timerText() {
		return { font: "Pirata One", fontSize: 42, fill: "#FF0000" };
	}
};

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var loadMainSockets = function loadMainSockets(socket, gm, serverInfo) {
  /***
   * MAIN SOCKETS
   * Some sockets are persistent across states
   * They are defined ONCE here, in the waiting area, and uses throughout the game
   */

  socket.on('next-state', function (data) {
    // set the timer
    if (serverInfo.vip) {
      serverInfo.timer = data.timer;
    }

    // save the canvas (otherwise it is also removed when the GUI is removed)
    var cv = document.getElementById("canvas-container");
    cv.style.display = 'none';
    document.body.appendChild(cv);

    // clear the GUI
    document.getElementById("main-controller").innerHTML = '';

    // start the next state
    gm.state.start('Controller' + data.nextState);
  });

  // presignals are always a single OBJECT
  // every key in the object is added to the serverInfo, along with its value
  // (this always happens before a state change, thus the name presignal)
  socket.on('pre-signal', function (data) {
    console.log("Presignal", JSON.stringify(data));
    for (var key in data) {
      // if it's a roleUpdate => permanently update our level! (which role should be updated, is saved in data[key])
      if (key.substring(0, 10) == 'roleUpdate') {
        serverInfo.roleStats[data[key]].lvl++;
      } else if (key.substring(0, 9) == 'roleStats') {
        // if it's a role stat, get the role number, and which stat to change, and set it to the new value
        serverInfo.roleStats[data[key][0]][data[key][1]] = data[key][2];
      } else {
        // otherwise, just blindly set the key to this value
        serverInfo[key] = data[key];
      }
    }
  });

  // force disconnect (because game has been stopped/removed)
  socket.on('force-disconnect', function (data) {
    socket.disconnect(true);
    window.location.reload(false);
  });

  socket.on('pause-resume-game', function (data) {
    if (!serverInfo.vip) {
      return;
    }

    if (data) {
      // if we're already paused, don't add another set of buttons and options for the vip
      // so, first check if this is our first pause
      if (!serverInfo.paused) {
        var div = document.getElementById("main-controller");

        var span = document.createElement("span");
        div.insertBefore(span, div.firstChild);

        // 1. add text to explain the situation
        var p1 = document.createElement("p");
        p1.innerHTML = serverInfo.translate("player-disconnect-1");
        span.appendChild(p1);

        var p2 = document.createElement("p");
        p2.innerHTML = serverInfo.translate("player-disconnect-2");
        span.appendChild(p2);

        // 2. add buttons for continuing without player, or stopping game altogether
        var btn1 = document.createElement("button");
        btn1.innerHTML = serverInfo.translate('continue-game');
        btn1.addEventListener('click', function (event) {
          socket.emit('continue-without-disconnects', {});

          // remove the pause GUI
          gm.pauseObject.innerHTML = '';
          gm.pauseObject.remove();

          // unpause the game
          serverInfo.paused = false;
        });
        span.appendChild(btn1);

        var btn2 = document.createElement("button");
        btn2.innerHTML = serverInfo.translate('destroy-game');
        btn2.addEventListener('click', function (event) {
          socket.emit('destroy-game', {});
        });
        span.appendChild(btn2);

        // 3. Add a horizontal rule to separate GUIs and add more space
        var hr = document.createElement("hr");
        span.appendChild(hr);

        // 4. and save all these somewhere so they can be removed (on button click, or when the game resumes)
        gm.pauseObject = span;

        serverInfo.paused = true;
      }
    } else {
      // remove the GUI that displays when the game is paused
      gm.pauseObject.innerHTML = '';
      gm.pauseObject.remove();

      serverInfo.paused = false;
    }
  });

  /***
   * END MAIN SOCKETS
   */
};

exports.default = loadMainSockets;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var ROLE_DICTIONARY = exports.ROLE_DICTIONARY = ['Captain', 'First Mate', 'Cartographer', 'Sailor', 'Cannoneer'];

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var loadWatchRoom = function loadWatchRoom(socket, serverInfo) {
  if (serverInfo.gameLoading) {
    socket.emit('finished-loading', {});

    serverInfo.gameLoading = false;
  }
};

exports.default = loadWatchRoom;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
var loadRejoinRoom = function loadRejoinRoom(socket, serverInfo, div) {
	// if we have rejoined the room ...
	if (serverInfo.rejoin) {
		var p1 = document.createElement("p");
		p1.innerHTML = serverInfo.translate("succesful-rejoin");
		div.appendChild(p1);

		serverInfo.rejoin = false;

		// if we were already done for this phase
		if (serverInfo.playerDone) {
			var p2 = document.createElement("p");
			p2.innerHTML = serverInfo.translate('player-already-done');
			div.appendChild(p2);

			return true;
		} else {
			return false;
		}
	}
	return false;
};

exports.default = loadRejoinRoom;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var SHIP_COLORS = exports.SHIP_COLORS = ['#FFAAAA', '#AAFFAA', '#AAAAFF', '#FFAAFF', '#FFFFAA', '#AAFFFF'];

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
		value: true
});
var loadGUIOverlay = function loadGUIOverlay(gm, serverInfo, style1, style2) {
		// display the room code
		var text = gm.add.text(gm.width - 20, 20, serverInfo.roomCode, style1);
		text.anchor.setTo(1.0, 0);

		//display text above it to make clear that this is a room code
		var text2 = gm.add.text(gm.width - 20, 20 + 12, serverInfo.translate('room').toUpperCase(), style2);
		text2.anchor.setTo(1.0, 1.0);
};

exports.default = loadGUIOverlay;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var gameTimer = exports.gameTimer = function gameTimer(ths, serverInfo) {
  if (serverInfo.paused) {
    return;
  }

  if (ths.timer > 0) {
    ths.timer -= ths.game.time.elapsed / 1000;
    ths.timerText.text = Math.ceil(ths.timer);
  } else {
    ths.timerText.text = "Time's up!";
  }
};

var controllerTimer = exports.controllerTimer = function controllerTimer(ths, serverInfo) {
  // If we're paused, or the timer has already run out, stop counting down (and sending timer signals)
  if (serverInfo.paused || ths.timer <= 0) {
    return;
  }

  // Perform countdown, if we're VIP
  if (serverInfo.vip) {
    ths.timer -= ths.game.time.elapsed / 1000;

    if (ths.timer <= 0) {
      serverInfo.socket.emit('timer-complete', {});
    }
  }
};

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
 * A speed-improved perlin and simplex noise algorithms for 2D.
 *
 * Based on example code by Stefan Gustavson (stegu@itn.liu.se).
 * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
 * Better rank ordering method by Stefan Gustavson in 2012.
 * Converted to Javascript by Joseph Gentle.
 *
 * Version 2012-03-09
 *
 * This code was placed in the public domain by its original author,
 * Stefan Gustavson. You may use it as you see fit, but
 * attribution is appreciated.
 *
 */

function Grad(x, y, z) {
  var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

  this.x = x;this.y = y;this.z = z;this.w = w;
}

Grad.prototype.dot2 = function (x, y) {
  return this.x * x + this.y * y;
};

Grad.prototype.dot3 = function (x, y, z) {
  return this.x * x + this.y * y + this.z * z;
};

Grad.prototype.dot4 = function (x, y, z, w) {
  return this.x * x + this.y * y + this.z * z + this.w * w;
};

var grad3 = [new Grad(1, 1, 0), new Grad(-1, 1, 0), new Grad(1, -1, 0), new Grad(-1, -1, 0), new Grad(1, 0, 1), new Grad(-1, 0, 1), new Grad(1, 0, -1), new Grad(-1, 0, -1), new Grad(0, 1, 1), new Grad(0, -1, 1), new Grad(0, 1, -1), new Grad(0, -1, -1)];

var grad4 = [new Grad(1, 1, 1, 0), new Grad(-1, 1, 1, 0), new Grad(1, -1, 1, 0), new Grad(1, 1, -1, 0), new Grad(-1, -1, 1, 0), new Grad(1, -1, -1, 0), new Grad(-1, 1, -1, 0), new Grad(-1, -1, -1, 0), new Grad(1, 1, 0, 1), new Grad(-1, 1, 0, 1), new Grad(1, -1, 0, 1), new Grad(1, 1, 0, -1), new Grad(-1, -1, 0, 1), new Grad(1, -1, 0, -1), new Grad(-1, 1, 0, -1), new Grad(-1, -1, 0, -1), new Grad(1, 0, 1, 1), new Grad(-1, 0, 1, 1), new Grad(1, 0, -1, 1), new Grad(1, 0, 1, -1), new Grad(-1, 0, -1, 1), new Grad(1, 0, -1, -1), new Grad(-1, 0, 1, -1), new Grad(-1, 0, -1, -1), new Grad(0, 1, 1, 1), new Grad(0, -1, 1, 1), new Grad(0, 1, -1, 1), new Grad(0, 1, 1, -1), new Grad(0, -1, -1, 1), new Grad(0, 1, -1, -1), new Grad(0, -1, 1, -1), new Grad(0, -1, -1, -1)];

var p = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180];
// To remove the need for index wrapping, double the permutation table length
var perm = new Array(512);
var gradP = new Array(512);

//noise.seed(0);

// ##### Perlin noise stuff

function fade(t) {
  return t * t * t * (t * (t * 6 - 15) + 10);
}

function lerp(a, b, t) {
  return (1 - t) * a + t * b;
}

module.exports = {
  // This isn't a very good seeding function, but it works ok. It supports 2^16
  // different seed values. Write something better if you need more seeds.
  seed: function seed(_seed) {
    if (_seed > 0 && _seed < 1) {
      // Scale the seed out
      _seed *= 65536;
    }

    _seed = Math.floor(_seed);
    if (_seed < 256) {
      _seed |= _seed << 8;
    }

    for (var i = 0; i < 256; i++) {
      var v;
      if (i & 1) {
        v = p[i] ^ _seed & 255;
      } else {
        v = p[i] ^ _seed >> 8 & 255;
      }

      perm[i] = perm[i + 256] = v;
      gradP[i] = gradP[i + 256] = grad4[v % 32]; //= grad3[v % 12];
    }
  },

  // 2D Perlin Noise
  perlin2: function perlin2(x, y) {
    // Find unit grid cell containing point
    var X = Math.floor(x),
        Y = Math.floor(y);
    // Get relative xy coordinates of point within that cell
    x = x - X;y = y - Y;
    // Wrap the integer cells at 255 (smaller integer period can be introduced here)
    X = X & 255;Y = Y & 255;

    // Calculate noise contributions from each of the four corners
    var n00 = gradP[X + perm[Y]].dot2(x, y);
    var n01 = gradP[X + perm[Y + 1]].dot2(x, y - 1);
    var n10 = gradP[X + 1 + perm[Y]].dot2(x - 1, y);
    var n11 = gradP[X + 1 + perm[Y + 1]].dot2(x - 1, y - 1);

    // Compute the fade curve value for x
    var u = fade(x);

    // Interpolate the four results
    return lerp(lerp(n00, n10, u), lerp(n01, n11, u), fade(y));
  },

  // 3D Perlin Noise
  perlin3: function perlin3(x, y, z) {
    // Find unit grid cell containing point
    var X = Math.floor(x),
        Y = Math.floor(y),
        Z = Math.floor(z);
    // Get relative xyz coordinates of point within that cell
    x = x - X;y = y - Y;z = z - Z;
    // Wrap the integer cells at 255 (smaller integer period can be introduced here)
    X = X & 255;Y = Y & 255;Z = Z & 255;

    // Calculate noise contributions from each of the eight corners
    var n000 = gradP[X + perm[Y + perm[Z]]].dot3(x, y, z);
    var n001 = gradP[X + perm[Y + perm[Z + 1]]].dot3(x, y, z - 1);
    var n010 = gradP[X + perm[Y + 1 + perm[Z]]].dot3(x, y - 1, z);
    var n011 = gradP[X + perm[Y + 1 + perm[Z + 1]]].dot3(x, y - 1, z - 1);
    var n100 = gradP[X + 1 + perm[Y + perm[Z]]].dot3(x - 1, y, z);
    var n101 = gradP[X + 1 + perm[Y + perm[Z + 1]]].dot3(x - 1, y, z - 1);
    var n110 = gradP[X + 1 + perm[Y + 1 + perm[Z]]].dot3(x - 1, y - 1, z);
    var n111 = gradP[X + 1 + perm[Y + 1 + perm[Z + 1]]].dot3(x - 1, y - 1, z - 1);

    // Compute the fade curve value for x, y, z
    var u = fade(x);
    var v = fade(y);
    var w = fade(z);

    // Interpolate
    return lerp(lerp(lerp(n000, n100, u), lerp(n001, n101, u), w), lerp(lerp(n010, n110, u), lerp(n011, n111, u), w), v);
  },

  // 4d perlin noise
  perlin4: function perlin4(x, y, z, w) {
    // Find unit grid cell containing point
    var X = Math.floor(x),
        Y = Math.floor(y),
        Z = Math.floor(z),
        W = Math.floor(w);
    // Get relative xyzw coordinates of point within that cell
    x = x - X;y = y - Y;z = z - Z;w = w - W;
    // Wrap the integer cells at 255 (smaller integer period can be introduced here)
    X = X & 255;Y = Y & 255;Z = Z & 255;W = W & 255;

    // Calculate noise contributions from each of the SIXTEEN corners
    // (Just follow the patterns; every unique combination must appear exactly once)
    var n0000 = gradP[X + perm[Y + perm[Z + perm[W]]]].dot4(x, y, z, w);
    var n0001 = gradP[X + perm[Y + perm[Z + perm[W + 1]]]].dot4(x, y, z, w - 1);
    var n0010 = gradP[X + perm[Y + perm[Z + 1 + perm[W]]]].dot4(x, y, z - 1, w);
    var n0011 = gradP[X + perm[Y + perm[Z + 1 + perm[W + 1]]]].dot4(x, y, z - 1, w - 1);
    var n0100 = gradP[X + perm[Y + 1 + perm[Z + perm[W]]]].dot4(x, y - 1, z, w);
    var n0101 = gradP[X + perm[Y + 1 + perm[Z + perm[W + 1]]]].dot4(x, y - 1, z, w - 1);
    var n0110 = gradP[X + perm[Y + 1 + perm[Z + 1 + perm[W]]]].dot4(x, y - 1, z - 1, w);
    var n0111 = gradP[X + perm[Y + 1 + perm[Z + 1 + perm[W + 1]]]].dot4(x, y - 1, z - 1, w - 1);
    var n1000 = gradP[X + 1 + perm[Y + perm[Z + perm[W]]]].dot4(x - 1, y, z, w);
    var n1001 = gradP[X + 1 + perm[Y + perm[Z + perm[W + 1]]]].dot4(x - 1, y, z, w - 1);
    var n1010 = gradP[X + 1 + perm[Y + perm[Z + 1 + perm[W]]]].dot4(x - 1, y, z - 1, w);
    var n1011 = gradP[X + 1 + perm[Y + perm[Z + 1 + perm[W + 1]]]].dot4(x - 1, y, z - 1, w - 1);
    var n1100 = gradP[X + 1 + perm[Y + 1 + perm[Z + perm[W]]]].dot4(x - 1, y - 1, z, w);
    var n1101 = gradP[X + 1 + perm[Y + 1 + perm[Z + perm[W + 1]]]].dot4(x - 1, y - 1, z, w - 1);
    var n1110 = gradP[X + 1 + perm[Y + 1 + perm[Z + 1 + perm[W]]]].dot4(x - 1, y - 1, z - 1, w);
    var n1111 = gradP[X + 1 + perm[Y + 1 + perm[Z + 1 + perm[W + 1]]]].dot4(x - 1, y - 1, z - 1, w - 1);

    // Compute the fade curve value for x, y, z, w
    var a = fade(x);
    var b = fade(y);
    var c = fade(z);
    var d = fade(w);

    // Interpolate between all these points
    // Essentially, we interpolate one axis at a time: 
    // first the d axis, the result of that interpolated against c, the result of THAT interpolated against b, and finally those results interpolated against a
    return lerp(lerp(lerp(lerp(n0000, n0001, d), lerp(n0010, n0011, d), c), lerp(lerp(n0100, n0101, d), lerp(n0110, n0111, d), c), b), lerp(lerp(lerp(n1000, n1001, d), lerp(n1010, n1011, d), c), lerp(lerp(n1100, n1101, d), lerp(n1110, n1111, d), c), b), a);
  }
};

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = function (eventID, curTab, interfaceType) {
    var num = eventID.charAt(5); // get number from id

    console.log("Loading tab " + num);

    // disable old selected tab
    document.getElementById("label" + curTab.num).classList.remove('tabSelected');

    // enable new selected tab
    document.getElementById(eventID).classList.add('tabSelected');

    // save the canvas
    var cv = document.getElementById("canvas-container");
    cv.style.display = 'none';
    document.body.appendChild(cv);

    // in fact, empty the canvas completely 
    cv.myGame.world.removeAll();

    // then empty the interface area
    document.getElementById("shipInterface").innerHTML = '';

    // create the interface container
    var container = document.createElement("div");
    container.classList.add("roleInterface");
    container.id = "tab" + num;

    document.getElementById("shipInterface").appendChild(container);

    // now start loading the interface, for this ...
    //  ... the role is needed (obviously) in the form of its number
    //  ... the container is needed (because everything is going to be appended as a child there)

    // interfaceType "0" = preparation interface
    // interfaceType "1" = play interface
    if (interfaceType == 0) {
        (0, _loadPrepInterface2.default)(_serverInfo.serverInfo.myRoles[num], container);
    } else {
        (0, _loadPlayInterface2.default)(_serverInfo.serverInfo.myRoles[num], container);
    }

    // update current tab number
    curTab.num = num;
};

var _roleDictionary = __webpack_require__(7);

var _serverInfo = __webpack_require__(0);

var _loadPrepInterface = __webpack_require__(25);

var _loadPrepInterface2 = _interopRequireDefault(_loadPrepInterface);

var _loadPlayInterface = __webpack_require__(26);

var _loadPlayInterface2 = _interopRequireDefault(_loadPlayInterface);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

;

// I'm cheating here
// I pass curTab as a function with a property 'num', so it is passed by REFERENCE
// This way I can access the old tab, disable it, and then update to the new tab, without having to send the object back
// Bad practice, works well though :p

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = loadErrorMessage;

var _serverInfo = __webpack_require__(0);

var _roleDictionary = __webpack_require__(7);

var _clueStrings = __webpack_require__(29);

function loadErrorMessage(i) {
    var msgType = _serverInfo.serverInfo.errorMessages[i][0];
    var msgParam = _serverInfo.serverInfo.errorMessages[i][1];

    var finalMsg = '';
    var msgVisualType = 0; // 0 = error message, 1 = reward/feedback message
    switch (msgType) {
        case 0:
            finalMsg = 'Upgrade by <em>' + _roleDictionary.ROLE_DICTIONARY[msgParam] + '</em> failed!';
            break;

        case 1:
            finalMsg = 'Crew allocation by <em>' + _roleDictionary.ROLE_DICTIONARY[msgParam] + '</em> failed!';
            break;

        case 2:
            finalMsg = 'Purchase by <em>' + _roleDictionary.ROLE_DICTIONARY[msgParam] + '</em> failed!';
            break;

        case 3:
            finalMsg = "You don't have enough crew to fire the cannons!";
            break;

        case 4:
            finalMsg = 'You were attacked!';
            break;

        case 5:
            finalMsg = 'Your ship hit something.';
            break;

        case 6:
            finalMsg = 'Your cannonball hit a target!';
            msgVisualType = 1;
            break;

        case 7:
            finalMsg = 'You killed something! Check your resources for loot.';
            msgVisualType = 1;
            break;

        case 8:
            finalMsg = 'The game has started! Good luck!';
            msgVisualType = 1;
            break;

        case 9:
            finalMsg = 'Trade with dock failed!';
            break;

        case 10:
            finalMsg = "Asking around didn't yield any results!";
            break;

        case 11:
            finalMsg = 'Exploration failed!';
            break;

        case 12:
            finalMsg = "Congratulations! You have found the treasure of <strong>" + msgParam + "</strong>!";
            msgVisualType = 1;
            break;

        // This one's special: it handles ALL possible clues
        // msgParam is an object, containing the clue NUMBER, treasure NAME, and other necessary INFO
        case 13:
            // get clue from dictionary
            finalMsg = _clueStrings.CLUE_STRINGS[msgParam.num];

            // insert name (owner of treasure; unique identifier)
            finalMsg = finalMsg.replace('@[name]', msgParam.name);

            // insert all other variables/info
            // (the right values for these are already calculated on the server)
            for (var a = 0; a < msgParam.info.length; a++) {
                finalMsg = finalMsg.replace('@[' + a + ']', msgParam.info[a]);
            }

            msgVisualType = 1;
            break;

        case 14:
            finalMsg = 'Unfortunately, there was no treasure here';
            break;

    }

    var errorMsg = document.createElement("span");

    if (msgVisualType == 0) {
        errorMsg.classList.add("captain-error");
    } else {
        errorMsg.classList.add("captain-feedback");
    }

    errorMsg.setAttribute('data-errorid', i);
    errorMsg.innerHTML = "<p>" + finalMsg + "</p>";

    errorMsg.addEventListener('click', function () {
        _serverInfo.serverInfo.errorMessages[this.getAttribute('data-errorid')] = null;

        this.remove();
    });

    return errorMsg;
};

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Menu = __webpack_require__(17);

var _Menu2 = _interopRequireDefault(_Menu);

var _GameLobby = __webpack_require__(19);

var _GameLobby2 = _interopRequireDefault(_GameLobby);

var _GamePrep = __webpack_require__(20);

var _GamePrep2 = _interopRequireDefault(_GamePrep);

var _GamePlay = __webpack_require__(21);

var _GamePlay2 = _interopRequireDefault(_GamePlay);

var _GameOver = __webpack_require__(22);

var _GameOver2 = _interopRequireDefault(_GameOver);

var _ControllerLobby = __webpack_require__(23);

var _ControllerLobby2 = _interopRequireDefault(_ControllerLobby);

var _ControllerPrep = __webpack_require__(24);

var _ControllerPrep2 = _interopRequireDefault(_ControllerPrep);

var _ControllerPlay = __webpack_require__(30);

var _ControllerPlay2 = _interopRequireDefault(_ControllerPlay);

var _ControllerOver = __webpack_require__(32);

var _ControllerOver2 = _interopRequireDefault(_ControllerOver);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // menu is the waiting menu, where players either create or join a room

// game merely *displays* the game on the monitor


// controller means the handheld device a player uses


var App = function (_Phaser$Game) {
    _inherits(App, _Phaser$Game);

    function App() {
        _classCallCheck(this, App);

        // menu state
        var _this = _possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).call(this, '100%', '100%', Phaser.AUTO, 'canvas-container'));

        _this.state.add('Menu', _Menu2.default);

        // game monitor states
        _this.state.add('GameLobby', _GameLobby2.default);
        _this.state.add('GamePrep', _GamePrep2.default);
        _this.state.add('GamePlay', _GamePlay2.default);
        _this.state.add('GameOver', _GameOver2.default);

        // game controller states
        _this.state.add('ControllerLobby', _ControllerLobby2.default);
        _this.state.add('ControllerPrep', _ControllerPrep2.default);
        _this.state.add('ControllerPlay', _ControllerPlay2.default);
        _this.state.add('ControllerOver', _ControllerOver2.default);

        // start the game! (at the menu)
        _this.state.start('Menu');
        return _this;
    }

    return App;
}(Phaser.Game);

var SimpleGame = new App();

// augmenting standard JavaScript functions to make removal of overlay easier
// (we don't need the overlay at any point after the menu)
Element.prototype.remove = function () {
    this.parentElement.removeChild(this);
};
NodeList.prototype.remove = HTMLCollection.prototype.remove = function () {
    for (var i = this.length - 1; i >= 0; i--) {
        if (this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
};

exports.default = SimpleGame;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _serverInfo = __webpack_require__(0);

var _mainSocketsGame = __webpack_require__(2);

var _mainSocketsGame2 = _interopRequireDefault(_mainSocketsGame);

var _mainSocketsController = __webpack_require__(6);

var _mainSocketsController2 = _interopRequireDefault(_mainSocketsController);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Menu = function (_Phaser$State) {
  _inherits(Menu, _Phaser$State);

  function Menu() {
    _classCallCheck(this, Menu);

    return _possibleConstructorReturn(this, (Menu.__proto__ || Object.getPrototypeOf(Menu)).call(this));
    // construct stuff here, if needed
  }

  _createClass(Menu, [{
    key: 'preload',
    value: function preload() {
      // load stuff here
      //game.load.baseURL = 'https://trampolinedraak.herokuapp.com/';
      this.game.load.crossOrigin = 'Anonymous';
      this.game.stage.backgroundColor = "#FFFFFF";

      // We set this to true so our game won't pause if we focus
      // something else other than the browser
      this.game.stage.disableVisibilityChange = true;
    }
  }, {
    key: 'create',
    value: function create() {
      // do nothing, because we're waiting on players to make a choice
      console.log("Menu state");

      var gm = this.game;

      //gm.scale.scaleMode = Phaser.ScaleManager.RESIZE;
      //gm.scale.parentIsWindow = true;

      // function for creating a room (from start GUI overlay)
      document.getElementById('createRoomBtn').onclick = function () {
        // disable the button
        this.disabled = true;

        // Connects the player to the server
        _serverInfo.serverInfo.socket = io(_serverInfo.serverInfo.SERVER_IP);
        var socket = _serverInfo.serverInfo.socket;

        // Creates game room on server
        socket.on('connect', function () {
          document.getElementById("err-message").innerHTML = 'Creating room ...';
          socket.emit('new-room', {});
        });

        // Once the room has been succesfully created
        // save the room code, load the next screen
        socket.on('room-created', function (data) {
          _serverInfo.serverInfo.roomCode = data.roomCode;

          // remove the overlay
          document.getElementById("main").style.display = 'none';

          // Starts the "game" state
          gm.state.start('GameLobby');
        });
      };

      // function for joining a room (from start GUI overlay)
      document.getElementById('joinRoomBtn').onclick = function () {
        // disable the button
        var btn = this;
        btn.disabled = true;

        // fetches the inputs (which will be handed to the server on first connection)
        // to join the correct room
        var inputs = document.getElementsByClassName("joinInput");
        var roomCode = inputs[0].value.toUpperCase();
        var userName = inputs[1].value.toUpperCase();
        console.log(roomCode + " || " + userName);

        // Connects the player to the server
        _serverInfo.serverInfo.socket = io(_serverInfo.serverInfo.SERVER_IP);
        var socket = _serverInfo.serverInfo.socket;

        socket.on('connect', function () {
          document.getElementById("err-message").innerHTML = 'Joining ...';

          socket.emit('join-room', {
            roomCode: roomCode,
            userName: userName
          });
        });

        // if joining was successful, go to the correct state
        // if not succesful, give the player another try
        socket.on('join-response', function (data) {
          if (data.success) {
            // remove overlay
            document.getElementById("main").style.display = 'none';

            // load necessary info
            _serverInfo.serverInfo.vip = data.vip;
            _serverInfo.serverInfo.roomCode = roomCode;
            _serverInfo.serverInfo.rank = data.rank;

            // Starts the "controller" state
            gm.state.start('ControllerLobby');
          } else {
            document.getElementById("err-message").innerHTML = data.err;
            btn.disabled = false;
            socket.disconnect(true);
          }
        });
      };

      // Watching a room simply means showing the game state
      // An audience can watch on a separate screen, or you can use this to reconnect a MONITOR if it lost internet connection
      document.getElementById('watchRoomBtn').onclick = function () {
        // disable the button
        var btn = this;
        if (btn.disabled) {
          return;
        }
        btn.disabled = true;

        // fetches the inputs (which will be handed to the server on first connection)
        // to join the correct room
        var roomCode = document.getElementsByClassName("joinInput")[2].value.toUpperCase();

        // Connects the player to the server
        _serverInfo.serverInfo.socket = io(_serverInfo.serverInfo.SERVER_IP);
        var socket = _serverInfo.serverInfo.socket;

        socket.on('connect', function () {
          document.getElementById("err-message").innerHTML = 'Loading room ...';

          socket.emit('watch-room', {
            roomCode: roomCode
          });
        });

        // if joining was successful, go to the correct state
        // if not succesful, give the player another try (disconnect from socket for cleanliness, and saving bandwidth)
        socket.on('watch-response', function (data) {
          if (data.success) {
            // remove overlay
            document.getElementById("main").style.display = 'none';

            // load the main sockets
            (0, _mainSocketsGame2.default)(socket, gm, _serverInfo.serverInfo);

            // set the timer
            _serverInfo.serverInfo.timer = data.timer;

            // load the info (set the given variable on the serverInfo object)
            var preSignal = data.preSignal;
            if (preSignal != null) {
              _serverInfo.serverInfo[preSignal[0]] = preSignal[1];
            }

            _serverInfo.serverInfo.paused = data.paused;
            _serverInfo.serverInfo.gameLoading = true;

            // go to the correct state
            gm.state.start('Game' + data.gameState);
          } else {
            document.getElementById("err-message").innerHTML = data.err;

            btn.disabled = false;
            socket.disconnect(true);
          }
        });
      };
    }
  }, {
    key: 'update',
    value: function update() {
      // This is where we listen for input!
    }
  }]);

  return Menu;
}(Phaser.State);

exports.default = Menu;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var loadImageComplete = function loadImageComplete(gm, pos, dims, name) {
  var newSprite = gm.add.sprite(pos.x, pos.y, name);
  newSprite.width = dims.width;
  newSprite.height = dims.height;
  newSprite.anchor.setTo(0.5, 0.5);
};

exports.default = loadImageComplete;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _serverInfo = __webpack_require__(0);

var _dynamicLoadImage = __webpack_require__(4);

var _dynamicLoadImage2 = _interopRequireDefault(_dynamicLoadImage);

var _colors = __webpack_require__(1);

var _loadPlayerVisuals = __webpack_require__(3);

var _loadPlayerVisuals2 = _interopRequireDefault(_loadPlayerVisuals);

var _mainSocketsGame = __webpack_require__(2);

var _mainSocketsGame2 = _interopRequireDefault(_mainSocketsGame);

var _watchRoomModule = __webpack_require__(8);

var _watchRoomModule2 = _interopRequireDefault(_watchRoomModule);

var _styles = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GameLobby = function (_Phaser$State) {
  _inherits(GameLobby, _Phaser$State);

  function GameLobby() {
    _classCallCheck(this, GameLobby);

    return _possibleConstructorReturn(this, (GameLobby.__proto__ || Object.getPrototypeOf(GameLobby)).call(this));
  }

  _createClass(GameLobby, [{
    key: 'preload',
    value: function preload() {
      // Set scaling (as game monitors can also be any size)
      // Scale game to fit the entire window (and rescale when window is resized)
      var gm = this.game;

      gm.scale.scaleMode = Phaser.ScaleManager.RESIZE;
      window.addEventListener('resize', function () {
        gm.scale.refresh();
      });
      gm.scale.refresh();
    }
  }, {
    key: 'create',
    value: function create() {
      var gm = this.game;

      // display room code
      var text = gm.add.text(gm.width * 0.5, 20, _serverInfo.serverInfo.translate('room').toUpperCase() + ": " + _serverInfo.serverInfo.roomCode, _styles.mainStyle.mainText(gm.width * 0.8));
      text.anchor.setTo(0.5, 0);

      // explain that we're waiting for people to join
      var text2 = gm.add.text(gm.width * 0.5, 60, _serverInfo.serverInfo.translate('game-waiting-1'), _styles.mainStyle.subText(gm.width * 0.8));
      text2.anchor.setTo(0.5, 0);

      var socket = _serverInfo.serverInfo.socket;

      socket.on('new-player', function (data) {
        var x = gm.width * 0.5;
        var y = 120 + data.rank * 60;
        var newItem = gm.add.text(x, y, data.name, _styles.mainStyle.mainText(gm.width, _colors.playerColors[data.rank]));
        newItem.anchor.setTo(0, 0.5);
      });

      socket.on('player-updated-profile', function (data) {
        if (data.profile != null) {
          var dataURI = data.profile;
          var imageName = 'profileImage' + data.name; // creates unique name by appending the username

          var x = gm.width * 0.5;
          var y = 120 + data.rank * 60;

          (0, _dynamicLoadImage2.default)(gm, { x: x - 100, y: y }, { width: 60, height: 78 }, imageName, dataURI);
        }

        // create a bubble at random location for each player
        //let randPos = [gm.width*Math.random(), (gm.height-300)*Math.random()];
        //var graphics = gm.add.graphics(0, 0);
        //graphics.beginFill(0xFF0000, 1);
        //graphics.drawCircle(randPos[0], randPos[1], 100);
      });

      (0, _mainSocketsGame2.default)(socket, gm, _serverInfo.serverInfo);
      (0, _watchRoomModule2.default)(socket, _serverInfo.serverInfo);

      console.log("Game lobby state");
    }

    // The shutdown function is called when we switch from one state to another
    // In it, I can clean up this state (e.g. by removing eventListeners) before we go to another

  }, {
    key: 'shutdown',
    value: function shutdown() {
      var socket = _serverInfo.serverInfo.socket;

      socket.off('new-player');
      socket.off('player-updated-profile');
    }
  }, {
    key: 'update',
    value: function update() {
      // This is where we listen for input!
    }
  }]);

  return GameLobby;
}(Phaser.State);

exports.default = GameLobby;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _serverInfo = __webpack_require__(0);

var _dynamicLoadImage = __webpack_require__(4);

var _dynamicLoadImage2 = _interopRequireDefault(_dynamicLoadImage);

var _colors = __webpack_require__(1);

var _loadPlayerVisuals = __webpack_require__(3);

var _loadPlayerVisuals2 = _interopRequireDefault(_loadPlayerVisuals);

var _mainSocketsGame = __webpack_require__(2);

var _mainSocketsGame2 = _interopRequireDefault(_mainSocketsGame);

var _watchRoomModule = __webpack_require__(8);

var _watchRoomModule2 = _interopRequireDefault(_watchRoomModule);

var _styles = __webpack_require__(5);

var _loadGUIOverlay = __webpack_require__(11);

var _loadGUIOverlay2 = _interopRequireDefault(_loadGUIOverlay);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GamePrep = function (_Phaser$State) {
  _inherits(GamePrep, _Phaser$State);

  function GamePrep() {
    _classCallCheck(this, GamePrep);

    return _possibleConstructorReturn(this, (GamePrep.__proto__ || Object.getPrototypeOf(GamePrep)).call(this));
  }

  _createClass(GamePrep, [{
    key: 'preload',
    value: function preload() {
      this.game.stage.backgroundColor = "#FFFFFF";
    }
  }, {
    key: 'create',
    value: function create() {
      var _this2 = this;

      var gm = this.game;
      var socket = _serverInfo.serverInfo.socket;

      gm.add.text(gm.width * 0.5 - 250, 20, 'Please look at your devices and perform the preparation for each role.', _styles.mainStyle.mainText(500, '#000000'));

      gm.add.text(gm.width * 0.5 - 250, 100, 'IMPORTANT: Submit your drawing/title/settings before switching to a different role, or you will lose your progress.', _styles.mainStyle.mainText(500, '#333333'));

      // display a loading bar
      this.loadingSprite = gm.add.sprite(gm.width * 0.5, 400, 'nonexistent_index');
      this.loadingSprite.anchor.setTo(0.5, 0.5);
      this.loadingSprite.height = 50;
      this.loadingSprite.width = 0;

      // update loading bar during the state (when progress signals are received from the server)
      // @parameter data => percentage of preparation that has finished
      socket.on('preparation-progress', function (data) {
        _this2.loadingSprite.width = 500 * data;
      });

      // load GUI overlay (displays room code and such)
      (0, _loadGUIOverlay2.default)(gm, _serverInfo.serverInfo, _styles.mainStyle.mainText(), _styles.mainStyle.subText());

      (0, _mainSocketsGame2.default)(socket, gm, _serverInfo.serverInfo);
      (0, _watchRoomModule2.default)(socket, _serverInfo.serverInfo);

      console.log("Game Preparation state");
    }

    // The shutdown function is called when we switch from one state to another

  }, {
    key: 'shutdown',
    value: function shutdown() {}
  }, {
    key: 'update',
    value: function update() {
      // This is where we listen for input!
    }
  }]);

  return GamePrep;
}(Phaser.State);

exports.default = GamePrep;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _serverInfo = __webpack_require__(0);

var _dynamicLoadImage = __webpack_require__(4);

var _dynamicLoadImage2 = _interopRequireDefault(_dynamicLoadImage);

var _colors = __webpack_require__(1);

var _loadPlayerVisuals = __webpack_require__(3);

var _loadPlayerVisuals2 = _interopRequireDefault(_loadPlayerVisuals);

var _mainSocketsGame = __webpack_require__(2);

var _mainSocketsGame2 = _interopRequireDefault(_mainSocketsGame);

var _watchRoomModule = __webpack_require__(8);

var _watchRoomModule2 = _interopRequireDefault(_watchRoomModule);

var _styles = __webpack_require__(5);

var _timers = __webpack_require__(12);

var _loadGUIOverlay = __webpack_require__(11);

var _loadGUIOverlay2 = _interopRequireDefault(_loadGUIOverlay);

var _perlinImproved = __webpack_require__(13);

var _perlinImproved2 = _interopRequireDefault(_perlinImproved);

var _shipColors = __webpack_require__(10);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GamePlay = function (_Phaser$State) {
    _inherits(GamePlay, _Phaser$State);

    function GamePlay() {
        _classCallCheck(this, GamePlay);

        return _possibleConstructorReturn(this, (GamePlay.__proto__ || Object.getPrototypeOf(GamePlay)).call(this));
    }

    _createClass(GamePlay, [{
        key: 'preload',
        value: function preload() {
            this.game.stage.backgroundColor = "#FFFFFF";

            /*
                Load all images into the cache
                The "preload" function waits until everything is loaded, before calling the create function
              Which should give us time to load all images
              */

            // monsters
            var mDrawings = _serverInfo.serverInfo.monsterDrawings;
            for (var i = 0; i < mDrawings.length; i++) {
                this.game.load.image('monsterNum' + i, mDrawings[i]);
            }

            if (mDrawings.length < 1) {
                this.game.load.image('monsterNum0', _serverInfo.serverInfo.backupMonsterDrawing);
                this.game.load.image('monsterNum1', _serverInfo.serverInfo.backupMonsterDrawing);
                this.game.load.image('monsterNum2', _serverInfo.serverInfo.backupMonsterDrawing);
            }

            // player ships
            var sDrawings = _serverInfo.serverInfo.shipDrawings;
            for (var _i = 0; _i < sDrawings.length; _i++) {
                this.game.load.image('shipNum' + _i, sDrawings[_i]);
            }

            if (sDrawings.length < 1) {
                this.game.load.image('shipNum0', _serverInfo.serverInfo.backupShipDrawing);
                this.game.load.image('shipNum1', _serverInfo.serverInfo.backupShipDrawing);
                this.game.load.image('shipNum2', _serverInfo.serverInfo.backupShipDrawing);
            }

            // ai ships
            var aiDrawings = _serverInfo.serverInfo.aiShipDrawings;
            for (var _i2 = 0; _i2 < aiDrawings.length; _i2++) {
                this.game.load.image('aiShipNum' + _i2, aiDrawings[_i2]);
            }

            if (aiDrawings.length < 1) {
                this.game.load.image('aiShipNum0', _serverInfo.serverInfo.backupShipDrawing);
                this.game.load.image('aiShipNum1', _serverInfo.serverInfo.backupShipDrawing);
                this.game.load.image('aiShipNum2', _serverInfo.serverInfo.backupShipDrawing);
                this.game.load.image('aiShipNum3', _serverInfo.serverInfo.backupShipDrawing);
            }

            // docks
            this.game.load.image('dock', _serverInfo.serverInfo.dockDrawing);

            // cities
            this.game.load.image('city', _serverInfo.serverInfo.dockDrawing);
        }
    }, {
        key: 'create',
        value: function create() {
            var _this2 = this;

            var gm = this.game;
            var socket = _serverInfo.serverInfo.socket;

            /***
                Recreate the map (based on the seed)
              This creates the 4D noise value on each location, and immediately displays the correct (colored) square
              ***/

            // seed the noise object (with the mapSeed)
            _perlinImproved2.default.seed(_serverInfo.serverInfo.mapSeed);

            // initialize some variables determining map size (and zoom level)
            var x1 = 0,
                y1 = 0,
                x2 = 10,
                y2 = 10;
            var mapWidth = 60,
                mapHeight = 30;

            this.mapWidth = mapWidth;
            this.mapHeight = mapHeight;

            this.map = []; //initialize map variable

            //var graphics = this.add.graphics(0, 0);
            var tileSize = Math.min(window.innerWidth / mapWidth, window.innerHeight / mapHeight);
            this.tileSize = tileSize;

            var baseMapGroup = gm.add.group();

            // loop through all tiles, determine noise level, and save it
            for (var y = 0; y < mapHeight; y++) {
                this.map[y] = [];
                for (var x = 0; x < mapWidth; x++) {
                    // 4D noise => wraps back to 2D map with seamless edges
                    var s = x / mapWidth;
                    var t = y / mapHeight;
                    var dx = x2 - x1;
                    var dy = y2 - y1;
                    var pi = Math.PI;

                    // Walk over two independent circles (perpendicular to each other)
                    var nx = x1 + Math.cos(s * 2 * pi) * dx / (2 * pi);
                    var nz = y1 + Math.sin(s * 2 * pi) * dy / (2 * pi);

                    var ny = x1 + Math.cos(t * 2 * pi) * dx / (2 * pi);
                    var nw = y1 + Math.sin(t * 2 * pi) * dy / (2 * pi);

                    // save the noise value
                    var curVal = _perlinImproved2.default.perlin4(nx, ny, nz, nw);
                    //this.map[y][x] = { val: curVal, checked: false, fog: true };
                    this.map[y][x] = { val: curVal, checked: false, fog: false }; // TO DO: Debugging

                    // display the map
                    var tileColor = void 0;
                    // DEEP OCEAN
                    if (curVal < -0.3) {
                        tileColor = '#1036CC';
                        // SHALLOW OCEAN
                    } else if (curVal < 0.2) {
                        tileColor = '#4169FF';
                        // BEACH
                    } else if (curVal < 0.25) {
                        tileColor = '#EED6AF';
                        // ISLAND
                    } else {
                        tileColor = '#228B22';
                    }

                    // create square, color it, add it as a sprite, add it to group
                    var tempTile = gm.add.bitmapData(this.tileSize, this.tileSize);
                    tempTile.rect(0, 0, tileSize, tileSize, tileColor);

                    var tempSprite = gm.add.sprite(x * this.tileSize, y * this.tileSize, tempTile);
                    baseMapGroup.add(tempSprite);

                    /*
                    graphics.drawRect(x*tileSize, y*tileSize, tileSize, tileSize);
                      graphics.lineStyle(1, 0xF9E4B7, 1); // last parameter is transparency: might be too expensive for the computer to set this to something else than 0
                    graphics.drawRect(x*tileSize, y*tileSize, tileSize, tileSize);
                    */
                }
            }

            // draw grid lines VERTICALLY
            for (var _x = 0; _x < mapWidth; _x++) {
                var _tempTile = gm.add.bitmapData(1, this.mapHeight * this.tileSize);
                _tempTile.line(0, 0, 0, this.mapHeight * this.tileSize, '#CCCCCC', 1);

                var _tempSprite = gm.add.sprite(_x * this.tileSize, 0, _tempTile);
                baseMapGroup.add(_tempSprite);
            }

            // draw grid lines HORIZONTALLY
            for (var _y = 0; _y < mapHeight; _y++) {
                var _tempTile2 = gm.add.bitmapData(this.mapWidth * this.tileSize, 1);
                _tempTile2.line(0, 0, this.mapWidth * this.tileSize, 0, '#CCCCCC', 1);

                var _tempSprite2 = gm.add.sprite(0, _y * this.tileSize, _tempTile2);
                baseMapGroup.add(_tempSprite2);
            }

            // put the complete base map into the cache
            baseMapGroup.cacheAsBitmap = true;

            /*
                Discover islands (cheaper to do it locally than to get it from the server)
              */
            this.discoverIslands();

            /*
                Create texture that holds all the shadows
              */
            this.unitShadows = gm.add.bitmapData(gm.width, gm.height);
            this.shadowSprite = gm.add.image(0, 0, this.unitShadows);
            //this.shadowSprite.blendMode = Phaser.blendModes.MULTIPLY;
            this.shadowSprite.alpha = 0.66;

            /*
                Display all units
                Some of the units need to be saved as SPRITES, so they can be moved around later.
              (These are the same units that need to load an image from a baseURI)
              This means that dynamicLoadImage doesn't work. 
                Instead, load all baseURIs into cache at the start, then just create sprites from them.
              */
            // Display docks
            var dotBmd = gm.add.bitmapData(tileSize, tileSize);
            dotBmd.circle(0.5 * tileSize, 0.5 * tileSize, 0.5 * tileSize, '#000000');

            var docks = _serverInfo.serverInfo.docks;
            this.dockSprites = [];
            for (var i = 0; i < docks.length; i++) {
                var _x2 = docks[i].x,
                    _y2 = docks[i].y;

                var cacheLabel = 'dock';

                // create the sprite
                var newSprite = gm.add.sprite(_x2 * tileSize, (_y2 - 0.5) * tileSize, cacheLabel);
                newSprite.width = newSprite.height = tileSize;

                newSprite.visible = false;
                newSprite.originalX = _x2;
                newSprite.originalY = _y2;

                this.dockSprites.push(newSprite);

                // also create THE DOT!
                var newDot = gm.add.sprite(_x2 * tileSize, _y2 * tileSize, dotBmd);
                newDot.width = newDot.height = tileSize;

                newSprite.myFogDot = newDot;
            }

            // Display cities
            var cities = _serverInfo.serverInfo.cities;
            this.citySprites = [];
            for (var _i3 = 0; _i3 < cities.length; _i3++) {
                var _x3 = cities[_i3].x,
                    _y3 = cities[_i3].y;

                var _cacheLabel = 'city';

                // create the sprite
                var _newSprite = gm.add.sprite(_x3 * tileSize, (_y3 - 0.5) * tileSize, _cacheLabel);
                _newSprite.width = _newSprite.height = tileSize;

                _newSprite.visible = false;
                _newSprite.originalX = _x3;
                _newSprite.originalY = _y3;

                this.citySprites.push(_newSprite);

                console.log(_x3, _y3);

                // also create THE DOT!
                var _newDot = gm.add.sprite(_x3 * tileSize, _y3 * tileSize, dotBmd);
                _newDot.width = _newDot.height = tileSize;

                _newSprite.myFogDot = _newDot;
            }

            console.log(cities);
            console.log(this.citySprites.length);

            // Display monsters
            console.log(_serverInfo.serverInfo.monsters);
            var monsters = _serverInfo.serverInfo.monsters;
            this.monsterSprites = [];
            for (var _i4 = 0; _i4 < monsters.length; _i4++) {
                var _x4 = monsters[_i4].x,
                    _y4 = monsters[_i4].y;

                var _cacheLabel2 = 'monsterNum' + monsters[_i4].myMonsterType;

                var _newSprite2 = gm.add.sprite(0, 0, _cacheLabel2);
                _newSprite2.width = _newSprite2.height = tileSize;
                _newSprite2.visible = false;
                this.monsterSprites.push(_newSprite2);

                // also create THE DOT!
                var _newDot2 = gm.add.sprite(_x4 * tileSize, _y4 * tileSize, dotBmd);
                _newDot2.width = _newDot2.height = tileSize;

                _newSprite2.myFogDot = _newDot2;
            }

            // Display AI Ships
            console.log(_serverInfo.serverInfo.aiShips);

            var aiShips = _serverInfo.serverInfo.aiShips;
            this.aiShipSprites = [];
            for (var _i5 = 0; _i5 < aiShips.length; _i5++) {
                var _x5 = aiShips[_i5].x,
                    _y5 = aiShips[_i5].y;

                var _cacheLabel3 = 'aiShipNum' + aiShips[_i5].myShipType;

                var _newSprite3 = gm.add.sprite(0, 0, _cacheLabel3);
                _newSprite3.width = _newSprite3.height = tileSize;
                _newSprite3.visible = false;
                this.aiShipSprites.push(_newSprite3);

                // also create THE DOT!
                var _newDot3 = gm.add.sprite(_x5 * tileSize, _y5 * tileSize, dotBmd);
                _newDot3.width = _newDot3.height = tileSize;

                _newSprite3.myFogDot = _newDot3;
            }

            // Display player Ships
            console.log(_serverInfo.serverInfo.playerShips);

            var playerShips = _serverInfo.serverInfo.playerShips;
            this.playerShipSprites = [];
            for (var _i6 = 0; _i6 < playerShips.length; _i6++) {
                var _x6 = playerShips[_i6].x,
                    _y6 = playerShips[_i6].y;
                var _cacheLabel4 = 'shipNum' + playerShips[_i6].num;

                var _newSprite4 = gm.add.sprite(0, 0, _cacheLabel4);
                _newSprite4.width = _newSprite4.height = tileSize;
                _newSprite4.visible = false;
                this.playerShipSprites.push(_newSprite4);

                // also create THE DOT!
                var _newDot4 = gm.add.sprite(_x6 * tileSize, _y6 * tileSize, dotBmd);
                _newDot4.width = _newDot4.height = tileSize;

                _newSprite4.myFogDot = _newDot4;
            }

            // Display fog
            this.fogBmd = gm.add.bitmapData(gm.width, gm.height);
            this.fogBmd.rect(0, 0, gm.width, gm.height, '#CCCCCC');

            var fogSprite = gm.add.sprite(0, 0, this.fogBmd);

            fogSprite.visible = false; // TO DO: Remove on deployment; just for debugging

            // move units to correct location, draw extras (shadows, etc.), or a dot if not visible
            this.moveUnits();

            // Display the messages from the radio
            // TO DO

            // Display NIGHT OVERLAY (for nighttime)
            this.shadowTexture = gm.add.bitmapData(gm.width, gm.height);
            this.lightSprite = gm.add.image(0, 0, this.shadowTexture);
            this.lightSprite.blendMode = Phaser.blendModes.MULTIPLY;
            this.lightSprite.visible = false;

            // load timer; the first turn is always twice as long!
            this.timerText = gm.add.text(gm.width * 0.5, 60, "", _styles.mainStyle.timerText());
            this.timer = _serverInfo.serverInfo.timer * 2;

            // load GUI overlay (displays room code and such)
            (0, _loadGUIOverlay2.default)(gm, _serverInfo.serverInfo, _styles.mainStyle.mainText(), _styles.mainStyle.subText());

            (0, _mainSocketsGame2.default)(socket, gm, _serverInfo.serverInfo);
            (0, _watchRoomModule2.default)(socket, _serverInfo.serverInfo);

            var ths = this;

            // Function that is activated when a new island is discovered
            socket.on('island-discovered', function (data) {
                // get island with this index
                var curIsland = _this2.islands[data.index];

                // reveal all tiles associated with this island
                var averageX = 0,
                    averageY = 0;
                for (var _i7 = 0; _i7 < curIsland.myTiles.length; _i7++) {
                    var _x7 = curIsland.myTiles[_i7][0],
                        _y7 = curIsland.myTiles[_i7][1];

                    averageX += _x7;
                    averageY += _y7;

                    _this2.map[_y7][_x7].fog = false;
                    ths.fogBmd.clear(_x7 * ths.tileSize, _y7 * ths.tileSize, ths.tileSize, ths.tileSize);
                }

                averageX /= curIsland.myTiles.length;
                averageY /= curIsland.myTiles.length;

                // display the island name on top of the island (add up and AVERAGE all x and y coordinates to get the center position)
                // TO DO: Averaging doesn't work with world wrapping. Find a solution for this
                gm.add.text(averageX * ths.tileSize, averageY * ths.tileSize, data.name, _styles.mainStyle.mainText());
            });

            // Function that is activated when a DOCK is discovered
            socket.on('dock-discovered', function (data) {
                // Get corresponding dock
                var curDock = _serverInfo.serverInfo.docks[data.index];
                var x = curDock.x,
                    y = curDock.y;

                // Add name on top of it
                // (give it a different color and wrap it sooner)
                gm.add.text(x * ths.tileSize, y * ths.tileSize, data.name, _styles.mainStyle.mainText(150, '#FFFF00'));

                // Clear the fog here
                _this2.map[y][x].fog = false;
                ths.fogBmd.clear(x * ths.tileSize, y * ths.tileSize, ths.tileSize, ths.tileSize);

                // TO DO
                // Always display the corresponding dock trade from now on
            });

            // Function that is activated when a CITY / TOWN is discovered
            socket.on('city-discovered', function (data) {
                // Get corresponding dock
                var curCity = _serverInfo.serverInfo.cities[data.index];
                var x = curCity.x,
                    y = curCity.y;

                // Add name on top of it
                // (give it a different color and wrap it sooner)
                gm.add.text(x * ths.tileSize, y * ths.tileSize, data.name, _styles.mainStyle.mainText(150, '#FF00FF'));

                // Clear the fog here
                _this2.map[y][x].fog = false;
                ths.fogBmd.clear(x * ths.tileSize, y * ths.tileSize, ths.tileSize, ths.tileSize);
            });

            // Function that is called whenever a new turn starts
            // Resets timer, resets other stuff, displays new situation, etc.
            socket.on('new-turn', function (data) {
                console.log("New turn => resetting timer to " + _serverInfo.serverInfo.timer);

                // reset the timer 
                ths.timer = _serverInfo.serverInfo.timer;

                // update fog
                // go through all discoveredTiles, remove the fog on them
                for (var _i8 = 0; _i8 < _serverInfo.serverInfo.discoveredTiles.length; _i8++) {
                    // get tile (by coordinates [x,y])
                    var _x8 = _serverInfo.serverInfo.discoveredTiles[_i8].x,
                        _y8 = _serverInfo.serverInfo.discoveredTiles[_i8].y;

                    // remove the fog, both behind the scenes, and visually
                    _this2.map[_y8][_x8].fog = false;
                    ths.fogBmd.clear(_x8 * ths.tileSize, _y8 * ths.tileSize, ths.tileSize, ths.tileSize);
                }

                // move all units to their new positions
                ths.moveUnits();

                // switch to day/night if necessary
                _serverInfo.serverInfo.turnCount++;
                if (_serverInfo.serverInfo.turnCount % 10 == 0) {
                    _serverInfo.serverInfo.dayTime = !_serverInfo.serverInfo.dayTime;

                    // if night, the overlay is turned on
                    // if day, the overlay is turned off
                    if (!_serverInfo.serverInfo.dayTime) {
                        _this2.lightSprite.visible = true;
                        _this2.updateShadowTexture();
                    } else {
                        _this2.lightSprite.visible = false;
                    }
                }

                // TO DO: Remove once night mode is active; now it's just annoying
                _this2.lightSprite.visible = false;

                if (!_serverInfo.serverInfo.dayTime) {
                    // update NIGHT OVERLAY; Only if it's actually nighttime!
                    _this2.updateShadowTexture();
                }
            });

            console.log("Game Play state");
        }
    }, {
        key: 'update',
        value: function update() {
            // Update timer
            (0, _timers.gameTimer)(this, _serverInfo.serverInfo);
        }
    }, {
        key: 'moveUnits',
        value: function moveUnits() {
            this.unitsOnMap = [];

            this.tempMap = [];
            for (var y = 0; y < this.mapHeight; y++) {
                this.tempMap[y] = [];
                for (var x = 0; x < this.mapWidth; x++) {
                    this.tempMap[y][x] = [0, 0]; // index 0 = number of units on tile, index 1 = current counter (when displaying)
                }
            }

            // create ONE array that holds all sprites
            // Simultaneously, check how many units are on a certain tile
            for (var i = 0; i < this.dockSprites.length; i++) {
                this.unitsOnMap.push(this.dockSprites[i]);
            }

            for (var _i9 = 0; _i9 < this.citySprites.length; _i9++) {
                this.unitsOnMap.push(this.citySprites[_i9]);
            }

            for (var _i10 = 0; _i10 < this.monsterSprites.length; _i10++) {
                this.monsterSprites[_i10].originalX = _serverInfo.serverInfo.monsters[_i10].x;
                this.monsterSprites[_i10].originalY = _serverInfo.serverInfo.monsters[_i10].y;

                this.unitsOnMap.push(this.monsterSprites[_i10]);
                this.tempMap[_serverInfo.serverInfo.monsters[_i10].y][_serverInfo.serverInfo.monsters[_i10].x][0]++;
            }

            for (var _i11 = 0; _i11 < this.aiShipSprites.length; _i11++) {
                this.aiShipSprites[_i11].originalX = _serverInfo.serverInfo.aiShips[_i11].x;
                this.aiShipSprites[_i11].originalY = _serverInfo.serverInfo.aiShips[_i11].y;

                this.unitsOnMap.push(this.aiShipSprites[_i11]);
                this.tempMap[_serverInfo.serverInfo.aiShips[_i11].y][_serverInfo.serverInfo.aiShips[_i11].x][0]++;
            }

            for (var _i12 = 0; _i12 < this.playerShipSprites.length; _i12++) {
                this.playerShipSprites[_i12].originalX = _serverInfo.serverInfo.playerShips[_i12].x;
                this.playerShipSprites[_i12].originalY = _serverInfo.serverInfo.playerShips[_i12].y;

                this.unitsOnMap.push(this.playerShipSprites[_i12]);
                this.tempMap[_serverInfo.serverInfo.playerShips[_i12].y][_serverInfo.serverInfo.playerShips[_i12].x][0]++;
            }

            // reset the shadow canvas, set the fill style to transparent black
            this.unitShadows.clear();
            this.unitShadows.context.fillStyle = '#000000';

            var disp = [0, -0.5]; // displacement of the unit; usually slightly above the tile, so it sticks out

            // for all sprites (monsters, AI ships, player ships), move the sprite, then draw the shadow underneath it
            for (var _i13 = 0; _i13 < this.unitsOnMap.length; _i13++) {
                // this code simply gets the current unit and checks if the tile is still in fog
                var curUnit = this.unitsOnMap[_i13];
                var isInFog = this.map[curUnit.originalY][curUnit.originalX].fog;

                // the code below is for repositioning and rescaling sprites, in case there are multiple on a single tile
                var getTile = this.tempMap[curUnit.originalY][curUnit.originalX];
                var unitsOnTile = getTile[0];
                var curCounter = getTile[1];

                var tempPos = [curUnit.originalX * this.tileSize, curUnit.originalY * this.tileSize];

                // scale down sprites, but not linearly (/unitsOnTile) => allow overlap, bigger sprites
                var newWidth = this.tileSize / Math.sqrt(unitsOnTile);

                // display as a column, with random horizontal placement
                tempPos[1] += (curCounter + 0.5) / unitsOnTile * this.tileSize - newWidth;
                tempPos[0] += this.tileSize - newWidth + (Math.random() * 0.2 - 0.4) * this.tileSize;

                // increase counter
                this.tempMap[this.unitsOnMap[_i13].originalY][this.unitsOnMap[_i13].originalX][1]++;

                if (isInFog) {
                    // only display the dot
                    curUnit.visible = false;
                    curUnit.myFogDot.visible = true;
                    this.game.world.bringToTop(curUnit.myFogDot);

                    // set it to the right position and scale
                    curUnit.myFogDot.width = curUnit.myFogDot.height = newWidth;
                    curUnit.myFogDot.x = tempPos[0];
                    curUnit.myFogDot.y = tempPos[1];
                } else {
                    curUnit.myFogDot.visible = false;

                    // display the sprite + the shadow
                    curUnit.visible = true;
                    curUnit.width = curUnit.height = newWidth;

                    // place the unit
                    curUnit.x = tempPos[0];
                    curUnit.y = tempPos[1];

                    // change color for player ships
                    // this.unitShadows.context.fillStyle = SHIP_COLORS[i];

                    // draw the shadow
                    this.unitShadows.context.beginPath();
                    this.unitShadows.context.ellipse(tempPos[0] + newWidth * 0.5, tempPos[1] + newWidth, newWidth * 0.5, newWidth * 0.3, 0, 0, 2 * Math.PI);
                    this.unitShadows.context.fill();
                }
            }

            this.unitShadows.dirty = true;
        }
    }, {
        key: 'updateShadowTexture',
        value: function updateShadowTexture() {
            this.shadowTexture.context.fillStyle = 'rgb(0, 0, 0)';
            this.shadowTexture.context.fillRect(0, 0, this.game.width, this.game.height);

            // For all docks, display a light
            var docks = this.dockSprites;
            for (var i = 0; i < docks.length; i++) {
                var x = docks[i].x + 0.5 * this.tileSize,
                    y = docks[i].y,
                    radius = this.tileSize * 2 + Math.random() * 0.2 * this.tileSize;

                var gradient = this.shadowTexture.context.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0, 'rgba(255, 150, 150, 1.0)');
                gradient.addColorStop(1, 'rgba(255, 150, 150, 0.0)');

                this.shadowTexture.context.beginPath();
                this.shadowTexture.context.fillStyle = gradient;
                this.shadowTexture.context.arc(x, y, radius, 0, Math.PI * 2, false);
                this.shadowTexture.context.fill();
            }

            this.shadowTexture.dirty = true;
        }
    }, {
        key: 'discoverIslands',
        value: function discoverIslands() {
            this.islands = []; // initialize islands variable

            for (var y = 0; y < this.mapHeight; y++) {
                for (var x = 0; x < this.mapWidth; x++) {
                    var curTile = this.map[y][x];

                    // if this tile is an island, but hasn't been checked yet, let's start a new island!
                    if (curTile.val >= 0.2 && !curTile.checked) {

                        // create new island (with unknown name, and no free spots/dock known)
                        var islandIndex = this.islands.length;
                        this.islands.push({ myTiles: [] });

                        // explore this tile (which automatically leads to the whole island)
                        this.exploreTile(curTile, x, y, islandIndex);
                    }
                }
            }
        }
    }, {
        key: 'exploreTile',
        value: function exploreTile(tile, x, y, islandIndex) {
            // also save the tile in the island object, for quick reference
            this.islands[islandIndex].myTiles.push([x, y]);

            // mark this tile as checked
            tile.checked = true;

            // check tiles left/right/top/bottom
            var positions = [[-1, 0], [1, 0], [0, 1], [0, -1]];

            for (var a = 0; a < 4; a++) {
                var tempX = this.wrapCoords(x + positions[a][0], this.mapWidth);
                var tempY = this.wrapCoords(y + positions[a][1], this.mapHeight);

                var newTile = this.map[tempY][tempX];
                // if tile is an island, and hasn't been checked, explore it!
                if (newTile.val >= 0.2 && !newTile.checked) {
                    this.exploreTile(newTile, tempX, tempY, islandIndex);
                }
            }
        }
    }, {
        key: 'wrapCoords',
        value: function wrapCoords(c, bound) {
            if (c < 0) {
                c += bound;
            } else if (c >= bound) {
                c -= bound;
            }
            return c;
        }
    }]);

    return GamePlay;
}(Phaser.State);

exports.default = GamePlay;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _serverInfo = __webpack_require__(0);

var _dynamicLoadImage = __webpack_require__(4);

var _dynamicLoadImage2 = _interopRequireDefault(_dynamicLoadImage);

var _colors = __webpack_require__(1);

var _loadPlayerVisuals = __webpack_require__(3);

var _loadPlayerVisuals2 = _interopRequireDefault(_loadPlayerVisuals);

var _mainSocketsGame = __webpack_require__(2);

var _mainSocketsGame2 = _interopRequireDefault(_mainSocketsGame);

var _watchRoomModule = __webpack_require__(8);

var _watchRoomModule2 = _interopRequireDefault(_watchRoomModule);

var _styles = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GameWaiting = function (_Phaser$State) {
  _inherits(GameWaiting, _Phaser$State);

  function GameWaiting() {
    _classCallCheck(this, GameWaiting);

    return _possibleConstructorReturn(this, (GameWaiting.__proto__ || Object.getPrototypeOf(GameWaiting)).call(this));
  }

  _createClass(GameWaiting, [{
    key: 'preload',
    value: function preload() {
      // Set scaling (as game monitors can also be any size)
      // Scale game to fit the entire window (and rescale when window is resized)
      var gm = this.game;

      gm.scale.scaleMode = Phaser.ScaleManager.RESIZE;
      window.addEventListener('resize', function () {
        gm.scale.refresh();
      });
      gm.scale.refresh();
    }
  }, {
    key: 'create',
    value: function create() {
      var gm = this.game;

      // display room code
      var text = gm.add.text(gm.width * 0.5, 20, _serverInfo.serverInfo.translate('room').toUpperCase() + ": " + _serverInfo.serverInfo.roomCode, _styles.mainStyle.mainText(gm.width * 0.8));
      text.anchor.setTo(0.5, 0);

      // explain that we're waiting for people to join
      var text2 = gm.add.text(gm.width * 0.5, 60, _serverInfo.serverInfo.translate('game-waiting-1'), _styles.mainStyle.subText(gm.width * 0.8));
      text2.anchor.setTo(0.5, 0);

      var socket = _serverInfo.serverInfo.socket;

      socket.on('new-player', function (data) {
        var x = gm.width * 0.5;
        var y = 120 + data.rank * 60;
        var newItem = gm.add.text(x, y, data.name, _styles.mainStyle.mainText(gm.width, _colors.playerColors[data.rank]));
        newItem.anchor.setTo(0, 0.5);
      });

      socket.on('player-updated-profile', function (data) {
        if (data.profile != null) {
          var dataURI = data.profile;
          var imageName = 'profileImage' + data.name; // creates unique name by appending the username

          var x = gm.width * 0.5;
          var y = 120 + data.rank * 60;

          (0, _dynamicLoadImage2.default)(gm, { x: x - 100, y: y }, { width: 60, height: 78 }, imageName, dataURI);
        }

        // create a bubble at random location for each player
        //let randPos = [gm.width*Math.random(), (gm.height-300)*Math.random()];
        //var graphics = gm.add.graphics(0, 0);
        //graphics.beginFill(0xFF0000, 1);
        //graphics.drawCircle(randPos[0], randPos[1], 100);
      });

      (0, _mainSocketsGame2.default)(socket, gm, _serverInfo.serverInfo);
      (0, _watchRoomModule2.default)(socket, _serverInfo.serverInfo);

      console.log("Game waiting state");
    }

    // The shutdown function is called when we switch from one state to another
    // In it, I can clean up this state (e.g. by removing eventListeners) before we go to another

  }, {
    key: 'shutdown',
    value: function shutdown() {
      var socket = _serverInfo.serverInfo.socket;

      socket.off('new-player');
      socket.off('player-updated-profile');
    }
  }, {
    key: 'update',
    value: function update() {
      // This is where we listen for input!
    }
  }]);

  return GameWaiting;
}(Phaser.State);

exports.default = GameWaiting;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _serverInfo = __webpack_require__(0);

var _colors = __webpack_require__(1);

var _mainSocketsController = __webpack_require__(6);

var _mainSocketsController2 = _interopRequireDefault(_mainSocketsController);

var _rejoinRoomModule = __webpack_require__(9);

var _rejoinRoomModule2 = _interopRequireDefault(_rejoinRoomModule);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ControllerLobby = function (_Phaser$State) {
  _inherits(ControllerLobby, _Phaser$State);

  function ControllerLobby() {
    _classCallCheck(this, ControllerLobby);

    return _possibleConstructorReturn(this, (ControllerLobby.__proto__ || Object.getPrototypeOf(ControllerLobby)).call(this));
    // construct stuff here, if needed
  }

  _createClass(ControllerLobby, [{
    key: 'preload',
    value: function preload() {
      // load stuff here, if needed
    }
  }, {
    key: 'create',
    value: function create() {
      var gm = this.game;
      var socket = _serverInfo.serverInfo.socket;

      var div = document.getElementById("main-controller");

      // display VIP message
      // and start button
      if (_serverInfo.serverInfo.vip) {
        var p2 = document.createElement("p");
        p2.innerHTML = _serverInfo.serverInfo.translate("vip-message-waiting");
        div.appendChild(p2);

        var btn1 = document.createElement("button");
        btn1.innerHTML = _serverInfo.serverInfo.translate("start-game");
        btn1.addEventListener('click', function (event) {
          if (btn1.disabled) {
            return;
          }

          btn1.disabled = true;

          // send message to server that we want to start
          socket.emit('start-game', {});

          // we don't need to go to the next state; that happens automatically when the server responds with "okay! we start!"
        });
        div.appendChild(btn1);
      }

      // ask user to draw their own profile pic
      var p3 = document.createElement("p");
      p3.innerHTML = _serverInfo.serverInfo.translate('controller-waiting-1');
      div.appendChild(p3);

      // move canvas inside GUI
      var canvas = document.getElementById("canvas-container");
      div.appendChild(canvas);

      // IMPORTANT: the canvas gets a reference to the game
      // (we need this reference to create bitmaps and scale the canvas = game properly)
      canvas.myGame = gm;

      // make canvas the correct size
      // check what's the maximum width or height we can use
      var maxWidth = document.getElementById('main-controller').clientWidth;
      // calculate height of the viewport, subtract the space lost because of text above the canvas, subtract space lost from button (height+padding+margin)
      var maxHeight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0) - canvas.getBoundingClientRect().top - (16 + 8 * 2 + 4 * 2);
      // determine the greatest width we can use (either the original width, or the width that will lead to maximum allowed height)
      var finalWidth = Math.min(maxWidth, maxHeight / 1.3);
      // scale the game immediately (both stage and canvas simultaneously)
      gm.scale.setGameSize(finalWidth, finalWidth * 1.3);

      // add a bitmap for drawing
      gm.bmd = gm.add.bitmapData(gm.width, gm.height);
      gm.bmd.ctx.strokeStyle = _colors.playerColors[_serverInfo.serverInfo.rank]; // THIS is the actual drawing color      
      gm.bmd.ctx.lineWidth = 10;
      gm.bmd.ctx.lineCap = 'round';
      gm.bmd.isDragging = false;
      gm.bmd.lastPoint = null;

      gm.canvasSprite = gm.add.sprite(0, 0, gm.bmd);

      // display button to submit drawing
      var btn2 = document.createElement("button");
      btn2.innerHTML = _serverInfo.serverInfo.translate("submit-drawing");
      btn2.addEventListener('click', function (event) {
        var dataURI = gm.bmd.canvas.toDataURL();

        // send the drawing to the server (including the information that it's a profile pic)
        socket.emit('submit-profile-pic', { dataURI: dataURI, type: "profile" });

        // Remove submit button
        btn2.remove();

        // Disable canvas
        canvas.style.display = 'none';

        if (!_serverInfo.serverInfo.vip) {
          p3.innerHTML = _serverInfo.serverInfo.translate('controller-waiting-2');
        } else {
          p3.innerHTML = '';
        }
      });
      div.appendChild(btn2);

      (0, _mainSocketsController2.default)(socket, gm, _serverInfo.serverInfo);

      console.log("Controller Lobby state");
    }
  }, {
    key: 'shutdown',
    value: function shutdown() {
      _serverInfo.serverInfo.socket.off('pre-signal');
    }
  }, {
    key: 'update',
    value: function update() {
      // This is where we listen for input!

      /***
       * DRAW STUFF
       ***/
      var gm = this.game;
      if (gm.input.activePointer.isUp) {
        gm.bmd.isDragging = false;
        gm.bmd.lastPoint = null;
      }

      if (gm.input.activePointer.isDown) {
        gm.bmd.isDragging = true;
        gm.bmd.ctx.beginPath();
        var newPoint = new Phaser.Point(gm.input.x, gm.input.y);

        if (gm.bmd.lastPoint) {
          gm.bmd.ctx.moveTo(gm.bmd.lastPoint.x, gm.bmd.lastPoint.y);
          gm.bmd.ctx.lineTo(newPoint.x, newPoint.y);
        }

        gm.bmd.lastPoint = newPoint;
        gm.bmd.ctx.stroke();

        gm.bmd.dirty = true;
      }
    }
  }]);

  return ControllerLobby;
}(Phaser.State);

exports.default = ControllerLobby;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _serverInfo = __webpack_require__(0);

var _colors = __webpack_require__(1);

var _mainSocketsController = __webpack_require__(6);

var _mainSocketsController2 = _interopRequireDefault(_mainSocketsController);

var _rejoinRoomModule = __webpack_require__(9);

var _rejoinRoomModule2 = _interopRequireDefault(_rejoinRoomModule);

var _roleDictionary = __webpack_require__(7);

var _loadTab = __webpack_require__(14);

var _loadTab2 = _interopRequireDefault(_loadTab);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ControllerPrep = function (_Phaser$State) {
  _inherits(ControllerPrep, _Phaser$State);

  function ControllerPrep() {
    _classCallCheck(this, ControllerPrep);

    return _possibleConstructorReturn(this, (ControllerPrep.__proto__ || Object.getPrototypeOf(ControllerPrep)).call(this));
    // construct stuff here, if needed
  }

  _createClass(ControllerPrep, [{
    key: 'preload',
    value: function preload() {
      // load stuff here, if needed
    }
  }, {
    key: 'create',
    value: function create() {
      var gm = this.game;
      var socket = _serverInfo.serverInfo.socket;
      var curTab = { num: 0 };

      var div = document.getElementById("main-controller");

      // Add the health bar at the top
      var healthBar = document.createElement("div");
      healthBar.id = "healthBar";
      healthBar.classList.add('shipColor' + _serverInfo.serverInfo.myShip); // set bar to the right color
      div.appendChild(healthBar);

      // Add the ship info (name + flag)
      var shipInfo = document.createElement("div");
      shipInfo.id = 'shipInfo';
      shipInfo.innerHTML = '<img src="assets/pirate_flag.jpg" /> == Untitled Ship == ';
      shipInfo.classList.add('shipColor' + _serverInfo.serverInfo.myShip); // set font to the right color
      div.appendChild(shipInfo);

      // Add the tabs for switching roles
      // first create the container
      var shipRoles = document.createElement("div");
      shipRoles.id = 'shipRoles';

      // then add the roles
      var roles = _serverInfo.serverInfo.myRoles;
      for (var i = 0; i < roles.length; i++) {
        var roleNum = roles[i];

        // create a new tab object (with correct/unique label and z-index)
        var newTab = document.createElement("span");
        newTab.classList.add("shipRoleGroup");
        newTab.id = 'label' + i;
        newTab.style.zIndex = 5 - i;

        // add the ICON and the ROLE NAME within the tab
        newTab.innerHTML = '<img src="assets/roleIcon' + roleNum + '.png"/><span class="shipRoleTitle">' + _roleDictionary.ROLE_DICTIONARY[roleNum] + '</span>';

        // when you click this tab, unload the previous tab, and load the new one!
        // REMEMBER: "this" is the object associated with the event listener, "ev.target" is the thing that was actually clicked
        newTab.addEventListener('click', function (ev) {
          ev.preventDefault();
          (0, _loadTab2.default)(this.id, curTab, 0);
        });

        shipRoles.appendChild(newTab);
      }

      // finally, add the whole thing to the page
      div.appendChild(shipRoles);

      // add the area for the role interface
      var shipInterface = document.createElement("div");
      shipInterface.id = 'shipInterface';
      div.appendChild(shipInterface);

      // automatically load the first role 
      // (by calling LOAD_TAB with value "label0"; the other 0 determines its the preparation interface, not the play interface)
      (0, _loadTab2.default)("label0", curTab, 0);

      (0, _mainSocketsController2.default)(socket, gm, _serverInfo.serverInfo);

      console.log("Controller Preparation state");
    }
  }, {
    key: 'shutdown',
    value: function shutdown() {
      _serverInfo.serverInfo.socket.off('pre-signal');
    }
  }, {
    key: 'update',
    value: function update() {
      // This is where we listen for input (such as drawing)!

      /***
       * DRAW STUFF
       ***/
      var gm = this.game;
      if (gm.input.activePointer.isUp) {
        gm.bmd.isDragging = false;
        gm.bmd.lastPoint = null;
      }

      if (gm.input.activePointer.isDown) {
        gm.bmd.isDragging = true;
        gm.bmd.ctx.beginPath();
        var newPoint = new Phaser.Point(gm.input.x, gm.input.y);

        if (gm.bmd.lastPoint) {
          gm.bmd.ctx.moveTo(gm.bmd.lastPoint.x, gm.bmd.lastPoint.y);
          gm.bmd.ctx.lineTo(newPoint.x, newPoint.y);
        }

        gm.bmd.lastPoint = newPoint;
        gm.bmd.ctx.stroke();

        gm.bmd.dirty = true;

        gm.bmd.hasBeenEdited = true;
      }
    }
  }]);

  return ControllerPrep;
}(Phaser.State);

exports.default = ControllerPrep;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = loadPrepInterface;

var _serverInfo = __webpack_require__(0);

var _shipColors = __webpack_require__(10);

/*
    This function loads the preparation interface for each role

    @parameter num => the number of the role to be loaded
    @parameter cont => the container into which to load the interface

*/
function loadPrepInterface(num, cont) {
    var socket = _serverInfo.serverInfo.socket;

    // Every role has an instructional paragraph at the top; thus we can declare it here
    // The default value is "Thank You!", for when someone already submitted this role
    var p0 = document.createElement("p");
    p0.innerHTML = 'Thank you!';
    cont.appendChild(p0);

    // if we already submitted this role, don't load everything again!
    if (_serverInfo.serverInfo.submittedPreparation[num] == true) {
        return;
    }

    // Otherwise, load the whole shabang!
    // This switch statement loads the required buttons, inputs, drawing area, etc.
    //   => The submit button is underneath this statement, because it's almost identical for each role
    //   => The canvas resizing code is also underneath this, because it needs the height of the button
    var input0 = document.createElement("input");
    input0.style.marginBottom = '5px';

    var canvas = document.getElementById("canvas-container");
    var canvasProportion = 1; // ratio of height to width => value of 2 means that height = width*2

    var requiredInfo = {}; // this variable stores the info that is to be submitted (and their type + id/name)

    switch (num) {
        // **Captain**: give title and draw ship
        case 0:
            // Instructions
            p0.innerHTML = 'Title your ship and draw it (side-view)';

            // Title input bar
            input0.type = "text";
            input0.id = "shipTitle";
            input0.placeholder = "The Black Pearl";
            cont.appendChild(input0);

            // Canvas (drawing area for SHIP)
            canvas.style.display = 'block';
            cont.appendChild(canvas);

            canvasProportion = 1;

            requiredInfo = { 'shipTitle': 'text', 'shipDrawing': 'drawing' };

            break;

        // **First mate**: write motto and draw flag
        case 1:
            // Instructions
            p0.innerHTML = 'Write a motto and draw your flag';

            // Motto input
            input0.type = "text";
            input0.id = "shipMotto";
            input0.placeholder = "Veni, vidi, vici!";
            cont.appendChild(input0);

            // Canvas (drawing area for FLAG)
            canvas.style.display = 'block';
            cont.appendChild(canvas);

            canvasProportion = 0.5; // (flags are wide rectangles, not squares, thus height = width*0.5)

            requiredInfo = { 'shipMotto': 'text', 'shipFlag': 'drawing' };

            break;

        // Cartographer: title seamonster and draw seamonster
        case 2:
            // Instructions
            p0.innerHTML = 'Draw a seamonster and name it';

            // Seamonster name input
            input0.type = "text";
            input0.id = "shipMonster";
            input0.placeholder = "The Kraken!";
            cont.appendChild(input0);

            // Canvas (drawing area for MONSTER)
            canvas.style.display = 'block';
            cont.appendChild(canvas);

            canvasProportion = 1;

            requiredInfo = { 'shipMonster': 'text', 'shipMonsterDrawing': 'drawing' };

            break;

        // Sailor: (slider) choose between crew and resources
        case 3:
            // Instructions
            p0.innerHTML = 'Do you want to start with lots of crew, or lots of wood?';

            // Slider input (left = more crew, right = more wood)
            input0.type = "range";
            input0.id = 'res1';
            input0.min = 0;
            input0.max = 4;
            input0.value = 2;
            cont.appendChild(input0);

            // clues about what the slider means at a certain point
            var span0 = document.createElement("span");
            span0.innerHTML = 'CREW';
            span0.style.float = 'left';
            cont.appendChild(span0);

            var span1 = document.createElement("span");
            span1.innerHTML = 'WOOD';
            span1.style.float = 'right';
            cont.appendChild(span1);

            requiredInfo = { 'res1': 'res2' };

            break;

        // Weapon Specialist: (slider) choose between gun powder and resources
        case 4:
            // Instructions
            p0.innerHTML = 'Do you want to start with lots of gun powder, or lots of wood?';

            // Slider input (left = more guns, right = more wood)
            input0.type = "range";
            input0.id = 'res3';
            input0.min = 0;
            input0.max = 4;
            input0.value = 2;
            cont.appendChild(input0);

            // clues about what the slider means at a certain point
            var span0 = document.createElement("span");
            span0.innerHTML = 'GUNS';
            span0.style.float = 'left';
            cont.appendChild(span0);

            var span1 = document.createElement("span");
            span1.innerHTML = 'WOOD';
            span1.style.float = 'right';
            cont.appendChild(span1);

            requiredInfo = { 'res3': 'res2' };

            break;
    }

    /*
         Submit button (for all roles)
         => What it submits, depends on the role
      */
    var btn1 = document.createElement("button");
    btn1.innerHTML = 'Submit information';
    btn1.addEventListener('click', function (event) {
        // Check if all required information has been filled in
        // Text input (slider input has default values)
        if (input0.type == "text" && input0.value.length < 1) {
            return;
            // Drawing input
        } else if (canvas.style.display == 'block' && !canvas.myGame.bmd.hasBeenEdited) {
            return;
        }

        // Remove submit button
        btn1.remove();

        var signalContent = {};

        for (var key in requiredInfo) {
            var t = requiredInfo[key]; // get the type
            // it's either a piece of text
            if (t == 'text') {
                signalContent[key] = input0.value;
                // a drawing
            } else if (t == 'drawing') {
                signalContent[key] = canvas.myGame.bmd.canvas.toDataURL(); // this seems convoluted ... can't I get the dataURI from canvas immediately?
                // or a slider, in which case the dictionary holds another id-name (a slider chooses between two things, mostly resources on the ship)
            } else if (t.substring(0, 3) == 'res') {
                signalContent[key] = 0 + parseInt(input0.value);
                signalContent[requiredInfo[key]] = 4 - input0.value;
            }
        }

        console.log(signalContent);

        // send the drawing and info to the server
        // the server doesn't need to know the role or ship => it can figure it out itself
        socket.emit('submit-preparation', signalContent);

        // Disable canvas (and save it!)
        canvas.style.display = 'none';
        document.body.appendChild(canvas);

        // Remember that we already submitted this one
        _serverInfo.serverInfo.submittedPreparation[num] = true;

        // Reload the current tab/role - only this time, we're already done, so it just loads a "submitted" message
        // Empty the thing first (otherwise, it just keeps adding stuff to it)
        cont.innerHTML = '';
        loadPrepInterface(num, cont);
    });
    cont.appendChild(btn1);

    /*
         Canvas preparation code
         => The canvas needs to be the right size
         => The bitmapData for drawing needs to be prepared
         => (... but only if the canvas is actually displayed, of course)
      */
    if (canvas.style.display == 'block') {
        // make canvas the correct size
        // SIZE = total screen size - height taken by elements above - height taken by the button
        // keep some padding on both sides (10 is average height padding/margin, 20 is the padding on the sides)
        var paddingY = 10;
        var paddingX = 20;
        var maxHeight = screen.height - (input0.getBoundingClientRect().top + input0.getBoundingClientRect().height) - (btn1.getBoundingClientRect().height + 5 * 2) - paddingY * 2 - 2;
        var maxWidth = document.getElementById('shipInterface').clientWidth - paddingX * 2; // screen.width is misleading, because the main controller sets a max width

        // scale to the biggest size that fits (the canvas is a SQUARE)
        var finalSize = Math.min(maxWidth, maxHeight / canvasProportion);
        // scale the game immediately (both stage and canvas simultaneously)
        canvas.myGame.scale.setGameSize(finalSize, finalSize * canvasProportion);

        // remove previous drawing (if any)
        if (canvas.myGame.canvasSprite != undefined) {
            canvas.myGame.canvasSprite.destroy();
        }

        // Create bitmap for canvas 
        // Use the ship color for drawing
        var bmd = canvas.myGame.add.bitmapData(canvas.myGame.width, canvas.myGame.height);
        bmd.ctx.strokeStyle = _shipColors.SHIP_COLORS[_serverInfo.serverInfo.myShip];
        bmd.ctx.lineWidth = 10;
        bmd.ctx.lineCap = 'round';
        bmd.isDragging = false;
        bmd.lastPoint = null;

        //  => add it to the game, so we can manipulate it in update() (this also automatically replaces the old one)
        canvas.myGame.bmd = bmd;

        //  => create a sprite, so we can actually see the bitmap
        canvas.myGame.canvasSprite = canvas.myGame.add.sprite(0, 0, bmd);
    }
};

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = loadPlayInterface;

var _serverInfo = __webpack_require__(0);

var _shipColors = __webpack_require__(10);

var _upgradeDictionary = __webpack_require__(27);

var _upgradeDictionary2 = _interopRequireDefault(_upgradeDictionary);

var _upgradeEffectsDictionary = __webpack_require__(28);

var _upgradeEffectsDictionary2 = _interopRequireDefault(_upgradeEffectsDictionary);

var _roleDictionary = __webpack_require__(7);

var _loadErrorMessage = __webpack_require__(15);

var _loadErrorMessage2 = _interopRequireDefault(_loadErrorMessage);

var _perlinImproved = __webpack_require__(13);

var _perlinImproved2 = _interopRequireDefault(_perlinImproved);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
    The functions below are HELPER FUNCTIONS for specific roles (that require interactivity beyond basic DOM stuff)
    (At the bottom of this file, the main "loadPlayInterface" function can be found)

    The compass needs to be moved (and snapped) to certain angles

    The cartographer needs to move the map around

    The sailor needs to calculate which sail/peddle levels it may set (mostly based on max speed and max change)

*/
function compassMove(ev) {
    ev.preventDefault();

    // rotate compass to match angle between mouse and center of compass

    // find center of compass
    var image1 = document.getElementById('firstmate-compassPointer');
    var rect1 = image1.getBoundingClientRect();
    var centerCoords = { x: rect1.left + rect1.width * 0.5, y: rect1.top + rect1.height * 0.5 };

    // get click position (mouse is default; otherwise use touch)
    var coords = { x: ev.pageX, y: ev.pageY };
    if (ev.type == 'touchmove') {
        coords = { x: ev.touches[0].pageX, y: ev.touches[0].pageY };
    }

    // calculate difference vector, determine angle from that
    var vec = [coords.x - centerCoords.x, coords.y - centerCoords.y];
    var angle = Math.atan2(vec[1], vec[0]) * 180 / Math.PI;
    if (angle < 0) {
        angle += 360;
    }

    // Lock angle to compass level 
    // Determine the maximum rotation per turn (based on compass level)
    var deltaAngle = _upgradeEffectsDictionary2.default[1][_serverInfo.serverInfo.roleStats[1].lvl].angle;

    // get distance from current angle to current ship orientation
    // if this distance is above delta, you're too far
    var getOldOrientation = _serverInfo.serverInfo.oldOrientation * 45; // convert old orientation into degrees
    var angleDiff = (angle - getOldOrientation + 180) % 360 - 180;

    if (angleDiff < -180) {
        angleDiff += 360;
    }

    if (Math.abs(angleDiff) > deltaAngle) {
        return;
    } else {
        // Snap angle to fixed directions (8 dir, around center)
        // Make sure angle is within the [0,360] range with a modulo
        angle = Math.round(angle % 360 / 45) * 45;

        // Update compass pointer
        document.getElementById('firstmate-compassPointer').style.transform = 'rotate(' + angle + 'deg)';
        document.getElementById('firstmate-compassPointer').setAttribute('data-angle', angle);
    }
}

/*
    This function sends the value of the compass to the server, once you've released it

    @socket => the current socket (used for sending the signal)
    @curOrientation => the current arrow orientation on the client, which is exactly the info we need to send
*/
function sendCompassInformation(socket, curOrientation) {
    // Send signal to the server (with the new orientation)
    // (below, we check if the orientation actually changed, and only THEN send the signal)
    var newOrient = Math.round(curOrientation / 45);

    // if these two are equal, we didn't change course, so we wouldn't send a signal
    if (newOrient != _serverInfo.serverInfo.oldOrientation) {
        socket.emit('compass-up', newOrient);
    }

    // Update our own orientation (to remember it when switching tabs)
    _serverInfo.serverInfo.orientation = newOrient;
}

function startCanvasDrag(ev) {
    // prevent actually dragging the image (which is default behaviour for most browsers in this situation)
    ev.preventDefault();

    // get coordinates (default is mouse; otherwise get touch)
    var coords = { x: ev.pageX, y: ev.pageY };
    if (ev.type == 'touchstart') {
        coords = { x: ev.touches[0].pageX, y: ev.touches[0].pageY };
    }

    // save the first point (on the canvas)
    document.getElementById('canvas-container').oldMovePoint = coords;

    document.addEventListener('mousemove', mapMove);
    document.addEventListener('touchmove', mapMove);
}

function stopCanvasDrag(ev) {
    document.removeEventListener('mousemove', mapMove);
    document.removeEventListener('touchmove', mapMove);
}

function mapMove(ev) {
    ev.preventDefault();

    var cv = document.getElementById('canvas-container');

    // get coordinates (default is mouse; otherwise touch)
    var coords = { x: ev.pageX, y: ev.pageY };
    if (ev.type == 'touchmove') {
        coords = { x: ev.touches[0].pageX, y: ev.touches[0].pageY };
    }

    // get movement delta
    var dx = coords.x - cv.oldMovePoint.x;
    var dy = coords.y - cv.oldMovePoint.y;

    // move camera according to delta
    cv.myGame.camera.x += dx;
    cv.myGame.camera.y += dy;

    // update oldMovePoint
    cv.oldMovePoint = coords;
}

function disableForbiddenMoves() {
    /* There are four reasons a move might be forbidden:
        => It changes the ship speed to a negative number
        => It changes the ship speed to a number ABOVE max speed
        => It changes the ship speed by TOO MUCH in a single turn 
        => It changes sail/peddles to a negative number (we can't have -1 crew rowing the boat")
        This function goes through all the moves and marks the forbidden ones.
        Then, we make sure to display these options as "forbidden", AND disallow pulling the slider towards it
    */

    // get old speed
    var oldSpeed = _serverInfo.serverInfo.oldSpeed;

    // get old sail/peddle level
    var oldSail = _serverInfo.serverInfo.roleStats[3].oldSailLvl;
    var oldPeddle = _serverInfo.serverInfo.roleStats[3].oldPeddleLvl;

    // get new/current sail/peddle level
    var curSail = _serverInfo.serverInfo.roleStats[3].sailLvl;
    var curPeddle = _serverInfo.serverInfo.roleStats[3].peddleLvl;

    // get speed stats
    var speedStats = _upgradeEffectsDictionary2.default[3][_serverInfo.serverInfo.roleStats[3].lvl];
    var maxSpeed = speedStats.speed;
    var maxChange = speedStats.change;

    // range for saving forbidden moves: lowest number allowed, highest number allowed
    // this will be set once we start marking forbidden options
    var allowedSailRange = [0, 0];
    var allowedPeddleRange = [0, 0];

    // determine range of change
    var changeRange = Math.ceil((_serverInfo.serverInfo.roleStats[3].lvl + 1) / 4);

    // check sail levels (assuming current peddle stays constant)
    for (var i = -changeRange; i <= changeRange; i++) {
        var newSpeed = oldSpeed + (curPeddle - oldPeddle) + i;

        if (oldSail + i < 0 || newSpeed < 0 || newSpeed > maxSpeed || Math.abs(newSpeed - oldSpeed) > maxChange) {
            document.getElementById('sailor-sail' + i).classList.add('sailor-forbidden');
            document.getElementById('sailor-sailCost' + i).classList.add('sailor-forbidden');
        } else {
            document.getElementById('sailor-sail' + i).classList.remove('sailor-forbidden');
            document.getElementById('sailor-sailCost' + i).classList.remove('sailor-forbidden');

            // Mark as ALLOWED
            // => check if the number is outside the current range; if so, update the range (to be bigger)!
            if (i < allowedSailRange[0]) {
                allowedSailRange[0] = i;
            } else if (i > allowedSailRange[1]) {
                allowedSailRange[1] = i;
            }
        }
    }

    // check peddle levels (assuming current peddle stays constant)
    for (var _i = -changeRange; _i <= changeRange; _i++) {
        var _newSpeed = oldSpeed + (curSail - oldSail) + _i;

        if (oldPeddle + _i < 0 || _newSpeed < 0 || _newSpeed > maxSpeed || Math.abs(_newSpeed - oldSpeed) > maxChange) {
            document.getElementById('sailor-peddle' + _i).classList.add('sailor-forbidden');
            document.getElementById('sailor-peddleCost' + _i).classList.add('sailor-forbidden');
        } else {
            document.getElementById('sailor-peddle' + _i).classList.remove('sailor-forbidden');
            document.getElementById('sailor-peddleCost' + _i).classList.remove('sailor-forbidden');

            // Mark as ALLOWED
            // => check if the number is outside the current range; if so, update the range (to be bigger)!
            if (_i < allowedPeddleRange[0]) {
                allowedPeddleRange[0] = _i;
            } else if (_i > allowedPeddleRange[1]) {
                allowedPeddleRange[1] = _i;
            }
        }
    }

    _serverInfo.serverInfo.roleStats[3].allowedSailRange = allowedSailRange;
    _serverInfo.serverInfo.roleStats[3].allowedPeddleRange = allowedPeddleRange;
}

/*

    @parameter role => the role that wants an upgrade (every role only has one upgrade)
    @parameter level => the level we're upgrading TOWARDS
    @parameter targetLevel => level we're building towards (for certain (cumulative) upgrades)
*/
function loadUpgradeButton(role, level) {
    var targetLevel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    var costs = _upgradeDictionary2.default[role][level];
    var curString = '';

    // an upgrade to level 0 is the same as buying ...
    if (level == 0) {
        curString += '<span class="upgradeButtonLabel">Buy</span>';
    } else {
        curString += '<span class="upgradeButtonLabel">Upgrade (lv ' + level + ')</span>';
    }

    // if we're buying, we need to consider cumulative costs
    // because, the thing we buy will IMMEDIATELY be of the same level as this role's other instruments
    if (level == 0) {
        costs = {};

        // For each level ...
        for (var i = 0; i <= targetLevel; i++) {
            var c = _upgradeDictionary2.default[role][i];

            // Go through the different resource costs at this level ...
            for (var key in c) {
                // If this resource isn't in our costs yet, add it (with this value)
                if (costs[key] == undefined) {
                    costs[key] = c[key];
                    // If this resource is already in the costs object, just add this value to it
                } else {
                    costs[key] += c[key];
                }
            }
        }
    }

    // display costs inside upgrade button
    for (var _key in costs) {
        curString += '<span class="upgradeResourcesNeeded"><img src="assets/resourceIcon' + _key + '.png" /><span>x' + costs[_key] + '</span></span>';
    }

    return curString;
}

function loadFireButton() {
    // display the word 'FIRE!' (so the user knows what this button is doing)
    var curString = '<span class="upgradeButtonLabel">FIRE!</span>';

    // calculate the crew costs for firing the weapons
    // formula is this: for each added level, we need 1/2 crew member more PER CANNON
    // as a result, by rounding, the required crew per cannon ranges from 1 to 4.
    var costs = { 1: _serverInfo.serverInfo.firingCosts };

    // display costs inside upgrade button
    for (var key in costs) {
        curString += '<span class="upgradeResourcesNeeded"><img src="assets/resourceIcon' + key + '.png" /><span>x' + costs[key] + '</span></span>';
    }

    return curString;
}

function loadExploreButton() {
    // display the word 'EXPLORE!' (this button controls both exploring parts of the ocean and asking around in cities)
    var curString = '<span class="upgradeButtonLabel">EXPLORE!</span>';

    // calculate the crew costs for exploration
    // TO DO: For now, it always costs 1 crew
    //        (also, don't forget to sync this between client and server)
    var costs = { 1: 1 };

    // display costs inside upgrade button
    for (var key in costs) {
        curString += '<span class="upgradeResourcesNeeded"><img src="assets/resourceIcon' + key + '.png" /><span>x' + costs[key] + '</span></span>';
    }

    return curString;
}

function loadDeal(deal) {
    var resDict = ['Gold', 'Crew', 'Wood', 'Ammo']; //resDict[ deal[0][0] ] for resource as a string

    var good1 = '<strong>' + deal[0][1] + ' x </strong><img src="assets/resourceIcon' + deal[0][0] + '.png" />';
    var good2 = '<img src="assets/resourceIcon' + deal[1][0] + '.png" />' + '<strong> x ' + deal[1][1] + '</strong>';

    return '<p class="captain-dockDeal">' + good1 + ' ==> ' + good2 + '</p>';
}

function displayUpgradeStats(role, level) {
    var curStats = _upgradeEffectsDictionary2.default[role][level];

    // TO DO: On max level, don't get next stats, and don't display stuff about it
    // Right now, it would throw an error trying to get level 7 (index 6) from the array
    var nextStats = _upgradeEffectsDictionary2.default[role][level + 1];

    var curString = '';

    for (var key in curStats) {
        var curLevel = curStats[key];
        var nextLevel = nextStats[key];

        // display which property is being upgraded (get it directly from the object)
        curString += key + ': ';

        // display the current level of this property
        curString += curLevel;

        // display next level (if you were to upgrade)
        if (nextLevel > curLevel) {
            curString += ' <span style="color:lightgreen;">(&uarr;' + nextLevel + ')</span>';
        } else if (nextLevel == curLevel) {
            curString += ' <span>(&middot;' + nextLevel + ')</span>';
        } else if (nextLevel < curLevel) {
            curString += ' <span style="color:red;">(&darr;' + nextLevel + ')</span>';
        }
    }

    return curString;
}

/*
    This function loads the preparation interface for each role

    @parameter num => the number of the role to be loaded
    @parameter cont => the container into which to load the interface

*/
function loadPlayInterface(num, cont) {
    var socket = _serverInfo.serverInfo.socket;

    // This switch statement loads the required buttons, inputs, sliders, etc. for a given role
    // It takes its settings from "serverInfo", which sould have the information (from a pre-signal)

    switch (num) {
        // **Captain**: 
        //  => display list of tasks (changes all the time; given by server)
        //  => display ship resources (only the 4 basic ones: gold, crew, wood, guns)
        case 0:
            // Display error messages
            // The loop is DESCENDING (rather than ASCENDING), because newer error messages should be displayed first
            var errorMsgContainer = document.createElement("span");
            errorMsgContainer.id = 'captain-errorMessageContainer';

            var msg = _serverInfo.serverInfo.errorMessages;
            for (var i = msg.length - 1; i >= 0; i--) {
                if (msg[i] == null) {
                    continue;
                }

                errorMsgContainer.appendChild((0, _loadErrorMessage2.default)(i));
            }

            cont.appendChild(errorMsgContainer);

            // Loop through all tasks
            var tasks = _serverInfo.serverInfo.taskList;

            var _loop = function _loop(_i2) {
                if (tasks[_i2] == null) {
                    return 'continue';
                }

                var taskType = tasks[_i2][0];
                var param = tasks[_i2][1];

                switch (taskType) {
                    // Battle => enemies are nearby
                    // No parameter.
                    case 0:
                        var span0 = document.createElement("span");
                        span0.classList.add("captain-task");
                        span0.innerHTML = "<p>One or more enemies are nearby. Attack?</p>";

                        var btn0 = document.createElement("button");
                        btn0.setAttribute('data-taskid', _i2);
                        btn0.classList.add('upgradeButton');
                        btn0.innerHTML = loadFireButton();
                        span0.appendChild(btn0);

                        btn0.addEventListener('click', function () {
                            // send signal to server
                            socket.emit('fire');

                            // pop this task off the list
                            // set it to null; it will just be ignored from now on
                            _serverInfo.serverInfo.taskList[this.getAttribute('data-taskid')] = null;

                            // remove this whole task block
                            span0.remove();
                        });

                        cont.appendChild(span0);

                        break;

                    // Discovery => an island has been discovered, and you may give it a name
                    // @parameter index of the island
                    case 1:
                        var span1 = document.createElement("span");
                        span1.classList.add("captain-task");
                        span1.innerHTML = "<p>You have discovered a mysterious island! What will you name it?</p>";

                        var inp1 = document.createElement("input");
                        inp1.type = "text";
                        inp1.placeholder = "Tortuga";
                        span1.appendChild(inp1);

                        var btn1 = document.createElement("button");
                        btn1.setAttribute('data-taskid', _i2);
                        btn1.innerHTML = 'Submit name';
                        span1.appendChild(btn1);

                        btn1.addEventListener('click', function () {
                            // prevent submitting an empty name
                            if (inp1.value.length < 1) {
                                return;
                            }

                            // send signal to server
                            socket.emit('name-island', { name: inp1.value, island: param });

                            // pop this task off the list
                            // set it to null; it will just be ignored from now on
                            _serverInfo.serverInfo.taskList[this.getAttribute('data-taskid')] = null;

                            // remove this whole task block
                            span1.remove();
                        });

                        cont.appendChild(span1);

                        break;

                    // Dock => you are adjacent to a dock and may trade
                    // @parameter the index of the dock (so you know what you can trade)
                    case 2:
                        var span2 = document.createElement("span");
                        span2.classList.add("captain-task");
                        span2.innerHTML = "<p>You are docked at a harbor. Want to trade?</p>";

                        // Display the proposed trade, saved in serverInfo.dockTrade
                        // TO DO: Make the trade look nice (with icons and all)
                        span2.innerHTML = loadDeal(param.deal);

                        var btn2 = document.createElement("button");
                        btn2.setAttribute('data-taskid', _i2);
                        btn2.innerHTML = 'Perform trade';
                        span2.appendChild(btn2);

                        btn2.addEventListener('click', function () {
                            // send signal to server
                            socket.emit('dock-trade', param.index);

                            // pop this task off the list
                            // set it to null; it will just be ignored from now on
                            _serverInfo.serverInfo.taskList[this.getAttribute('data-taskid')] = null;

                            // remove this whole task block
                            span2.remove();
                        });

                        cont.appendChild(span2);

                        break;

                    // Discovery => a dock has been discovered, and you may give it a name
                    // @parameter index of the dock
                    case 3:
                        var span3 = document.createElement("span");
                        span3.classList.add("captain-task");
                        span3.innerHTML = "<p>You have found a new dock! What will you name it?</p>";

                        var inp3 = document.createElement("input");
                        inp3.type = "text";
                        inp3.placeholder = "Diddly Dock";
                        span3.appendChild(inp3);

                        var btn3 = document.createElement("button");
                        btn3.setAttribute('data-taskid', _i2);
                        btn3.innerHTML = 'Submit name';
                        span3.appendChild(btn3);

                        btn3.addEventListener('click', function () {
                            // prevent submitting an empty name
                            if (inp3.value.length < 1) {
                                return;
                            }

                            // send signal to server
                            socket.emit('name-dock', { name: inp3.value, dock: param });

                            // pop this task off the list
                            // set it to null; it will just be ignored from now on
                            _serverInfo.serverInfo.taskList[this.getAttribute('data-taskid')] = null;

                            // remove this whole task block
                            span3.remove();
                        });

                        cont.appendChild(span3);

                        break;

                    // Discovery => a city has been discovered, and you may give it a name
                    // @parameter index of the city
                    case 4:
                        var span4 = document.createElement("span");
                        span4.classList.add("captain-task");
                        span4.innerHTML = "<p>You stumbled upon a small town! What will you name it?</p>";

                        var inp4 = document.createElement("input");
                        inp4.type = "text";
                        inp4.placeholder = "City of Stars";
                        span4.appendChild(inp4);

                        var btn4 = document.createElement("button");
                        btn4.setAttribute('data-taskid', _i2);
                        btn4.innerHTML = 'Submit name';
                        span4.appendChild(btn4);

                        btn4.addEventListener('click', function () {
                            // prevent submitting an empty name
                            if (inp4.value.length < 1) {
                                return;
                            }

                            // send signal to server
                            socket.emit('name-city', { name: inp4.value, city: param });

                            // pop this task off the list
                            // set it to null; it will just be ignored from now on
                            _serverInfo.serverInfo.taskList[this.getAttribute('data-taskid')] = null;

                            // remove this whole task block
                            span4.remove();
                        });

                        cont.appendChild(span4);

                        break;

                    // Exploration => you are near a city and can ask around for clues
                    // @parameter index of the city
                    case 5:
                        var span5 = document.createElement("span");
                        span5.classList.add("captain-task");
                        span5.innerHTML = "<p>The people in this town might know something. Want to ask around?</p>";

                        var btn5 = document.createElement("button");
                        btn5.setAttribute('data-taskid', _i2);
                        btn5.classList.add('upgradeButton');
                        btn5.innerHTML = loadExploreButton();
                        span5.appendChild(btn5);

                        btn5.addEventListener('click', function () {
                            // send signal to server
                            socket.emit('explore-city', param);

                            // pop this task off the list
                            // set it to null; it will just be ignored from now on
                            _serverInfo.serverInfo.taskList[this.getAttribute('data-taskid')] = null;

                            // remove this whole task block
                            span5.remove();
                        });

                        cont.appendChild(span5);

                        break;

                    // Exploration => you are at (deep) sea and can dive in search of clues
                    // @parameter ??
                    case 6:
                        var span6 = document.createElement("span");
                        span6.classList.add("captain-task");
                        span6.innerHTML = "<p>Want to dive and search for treasure?</p>";

                        var btn6 = document.createElement("button");
                        btn6.setAttribute('data-taskid', _i2);
                        btn6.classList.add('upgradeButton');
                        btn6.innerHTML = loadExploreButton();
                        span6.appendChild(btn6);

                        btn6.addEventListener('click', function () {
                            // send signal to server
                            socket.emit('explore-tile');

                            // pop this task off the list
                            // set it to null; it will just be ignored from now on
                            _serverInfo.serverInfo.taskList[this.getAttribute('data-taskid')] = null;

                            // remove this whole task block
                            span6.remove();
                        });

                        cont.appendChild(span6);

                        break;
                }
            };

            for (var _i2 = 0; _i2 < tasks.length; _i2++) {
                var _ret = _loop(_i2);

                if (_ret === 'continue') continue;
            }

            // Display resources underneath
            var resHeading = document.createElement("h1");
            resHeading.innerHTML = 'Resources';
            cont.appendChild(resHeading);

            var resDiv = document.createElement("div");
            resDiv.id = 'shipResources';

            for (var _i3 = 0; _i3 < 4; _i3++) {
                var curResVal = _serverInfo.serverInfo.resources[_i3];

                resDiv.innerHTML += '<span class="shipResourceGroup"><img src="assets/resourceIcon' + _i3 + '.png"><span id="shipResource' + _i3 + '">' + curResVal + '</span></span>';
            }

            cont.appendChild(resDiv);

            break;

        // **First mate**: 
        //  => display current orientation (in background)
        //  => compass (rotatable; sends info when released)
        //  => current compass level + upgrade button
        case 1:
            // Current orientation in background
            var bgOrient = document.createElement("img");
            bgOrient.src = "assets/shipGhostTopCompass.png";
            bgOrient.style.maxWidth = '100%';
            bgOrient.style.position = 'absolute';
            bgOrient.style.opacity = 0.5;

            bgOrient.style.transform = 'rotate(' + _serverInfo.serverInfo.oldOrientation * 45 + 'deg)';

            cont.appendChild(bgOrient);

            // Compass on top of that
            var bgCompass = document.createElement("img");
            bgCompass.src = "assets/compassBackground.png";
            bgCompass.style.maxWidth = '100%';
            bgCompass.style.position = 'absolute';

            cont.appendChild(bgCompass);

            // Show which part of the compas is disabled/"forbidden"
            /***
                 CREATING SVG ARC
             ***/
            var svg1 = document.createElementNS("http://www.w3.org/2000/svg", "svg");

            // set width and height
            svg1.setAttribute("width", "100%");
            svg1.setAttribute("viewBox", "0 0 100 100");
            svg1.style.position = "absolute";

            // get maximum steering angle + current orientation
            var deltaAngle = _upgradeEffectsDictionary2.default[1][_serverInfo.serverInfo.roleStats[1].lvl].angle;;
            var oldOrientation = _serverInfo.serverInfo.oldOrientation;

            // Don't display anything if we have full steering range
            if (deltaAngle < 180) {
                // get how large the gap should be
                var targetAngle = (0 + deltaAngle * 2) * 180 / Math.PI;

                // if we have no range, we need to make a "dot" at our current rotation, and make the rest a circle 
                if (targetAngle == 0) {
                    targetAngle = 0.1;
                }

                // set circle parameters
                var cx = 50,
                    cy = 50,
                    rx = 45,
                    ry = 45;
                var lineSize = 3;

                // determine start and end position
                var startPos = { x: cx + rx, y: cy };
                var endPos = { x: cx + Math.cos(targetAngle) * rx, y: cy + Math.sin(targetAngle) * ry

                    // determine large and sweep flags 
                    // (to ensure the arc always follows a circle)
                };var largeArc = 1;
                if (deltaAngle >= 90) {
                    largeArc = 0;
                }

                var sweepFlag = 1;
                if (deltaAngle == 0) {
                    sweepFlag = 0;
                }

                // move to start point, draw arc towards end point, make it a large arc.
                var tempPath = 'M ' + startPos.x + ' ' + startPos.y + ' ';
                tempPath += 'A ' + rx + ' ' + ry + ' 0 ' + largeArc + ' ' + sweepFlag + ' ' + endPos.x + ' ' + endPos.y;

                // create path (according to tempPath template)
                var newpath = document.createElementNS('http://www.w3.org/2000/svg', "path");
                newpath.setAttributeNS(null, "d", tempPath);
                newpath.setAttributeNS(null, "stroke", "red");
                newpath.setAttributeNS(null, "stroke-width", lineSize);
                newpath.setAttributeNS(null, "fill", "none");
                newpath.setAttributeNS(null, "stroke-linecap", "round");

                // add this path (which is an arc with a gap) to the SVG element
                svg1.appendChild(newpath);
            }

            // add complete SVG element to the container
            cont.appendChild(svg1);

            // rotate the SVG to match current ship rotation
            svg1.style.transform = 'rotate(' + (oldOrientation * 45 + deltaAngle) + 'deg)';

            /***
                 END OF SVG ARC CODE
             ***/

            // Now add the compass POINTER
            var compassPointer = document.createElement("img");
            compassPointer.src = "assets/compassPointer.png";
            compassPointer.id = 'firstmate-compassPointer';
            compassPointer.style.overflow = 'hidden';
            compassPointer.style.maxWidth = '100%';
            //compassPointer.style.position = 'absolute';
            compassPointer.style.transform = 'rotate(' + _serverInfo.serverInfo.orientation * 45 + 'deg)';

            cont.appendChild(compassPointer);

            // when the mouse is down, start listening to mouse movements
            compassPointer.addEventListener('mousedown', function (ev) {
                this.addEventListener('mousemove', compassMove);
                compassMove(ev); // already register a mouse move
            }, false);

            // do the same for touch events
            compassPointer.addEventListener('touchstart', function (ev) {
                ev.preventDefault();

                this.addEventListener('touchmove', compassMove);
                compassMove(ev);
            }, false);

            // when the mouse is released, stop moving the compass, send a signal with update (only if it actually changed), update my own info (for tab switching)
            compassPointer.addEventListener('mouseup', function (ev) {
                this.removeEventListener('mousemove', compassMove);
                sendCompassInformation(socket, compassPointer.getAttribute('data-angle'));
            }, false);

            // do the same for touch events
            compassPointer.addEventListener('touchend', function (ev) {
                ev.preventDefault();

                this.removeEventListener('touchmove', compassMove);
                sendCompassInformation(socket, compassPointer.getAttribute('data-angle'));
            }, false);

            break;

        // Cartographer: 
        //  => display part of the map on canvas (centered on ship)
        //  => arrows to move around
        //  => current map level + upgrade button
        case 2:
            // Get the canvas back
            var canvas = document.getElementById("canvas-container");
            canvas.style.display = 'block';
            cont.appendChild(canvas);

            // Resize canvas (simplified version of the prepInterface; we'll see if it works)
            // The canvas should be square, and width should be the limiting factor (never height)
            var paddingX = 20;
            var maxWidth = document.getElementById('shipInterface').clientWidth - paddingX * 2;
            canvas.myGame.scale.setGameSize(maxWidth, maxWidth);

            // LOAD THE MAP (or at least, the part that we can see)
            // Seed the noise generator
            _perlinImproved2.default.seed(_serverInfo.serverInfo.mapSeed);

            // Create graphics object
            var graphics = canvas.myGame.add.graphics(0, 0);

            // Get map size from the upgrade effect dictionary. 
            // This size is a "radius", so transform it into the actual region of tiles around the ship
            var mapSize = _upgradeEffectsDictionary2.default[2][_serverInfo.serverInfo.roleStats[2].lvl].range * 2 + 1;

            // TO DO: Not used at the moment (might only be needed at the server)
            var detailSize = _upgradeEffectsDictionary2.default[2][_serverInfo.serverInfo.roleStats[2].lvl].detail * 2 + 1;

            // TO DO
            // this is the total size of the map (displayed on monitor)
            // it should be consistent across all devices
            var globalMapWidth = 60;
            var globalMapHeight = 30;

            // this is the tile size used for displaying the map on this device only (usually to make the squares bigger/more zoomed in)
            // the larger the map, the LESS zoomed in you are, thus tiles are SMALLER
            var localTileSize = 120 - mapSize * 5;

            // Loop through our visible tiles
            // Make sure we center this around our ship!
            // Get the right noise value, color it correctly, display square of that color
            var x1 = 0,
                y1 = 0,
                x2 = 10,
                y2 = 10;
            for (var y = 0; y < mapSize; y++) {
                for (var x = 0; x < mapSize; x++) {
                    var xTile = _serverInfo.serverInfo.x - Math.floor(0.5 * mapSize) + x;
                    if (xTile < 0) {
                        xTile += globalMapWidth;
                    } else if (xTile >= globalMapWidth) {
                        xTile -= globalMapWidth;
                    }

                    var yTile = _serverInfo.serverInfo.y - Math.floor(0.5 * mapSize) + y;
                    if (yTile < 0) {
                        yTile += globalMapHeight;
                    } else if (yTile >= globalMapHeight) {
                        yTile -= globalMapHeight;
                    }

                    // 4D noise => wraps back to 2D map with seamless edges
                    var s = xTile / globalMapWidth;
                    var t = yTile / globalMapHeight;
                    var dx = x2 - x1;
                    var dy = y2 - y1;
                    var pi = Math.PI;

                    // Walk over two independent circles (perpendicular to each other)
                    var nx = x1 + Math.cos(s * 2 * pi) * dx / (2 * pi);
                    var nz = y1 + Math.sin(s * 2 * pi) * dy / (2 * pi);

                    var ny = x1 + Math.cos(t * 2 * pi) * dx / (2 * pi);
                    var nw = y1 + Math.sin(t * 2 * pi) * dy / (2 * pi);

                    // save the noise value
                    var curVal = _perlinImproved2.default.perlin4(nx, ny, nz, nw);

                    // DEEP OCEAN
                    if (curVal < -0.3) {
                        graphics.beginFill(0x1036CC);
                        // SHALLOW OCEAN
                    } else if (curVal < 0.2) {
                        graphics.beginFill(0x4169FF);
                        // BEACH
                    } else if (curVal < 0.25) {
                        graphics.beginFill(0xEED6AF);
                        // ISLAND
                    } else {
                        graphics.beginFill(0x228B22);
                    }

                    graphics.drawRect(x * localTileSize, y * localTileSize, localTileSize, localTileSize);
                }
            }

            // Set world bounds to the map size
            canvas.myGame.world.setBounds(0, 0, mapSize * localTileSize, mapSize * localTileSize);

            // Display units (the server determines which ones you can see, based on range and instrument level)

            // This information should be sent at the start of each turn, saved, and then read from "serverInfo.mapUnits"
            // NOTE: The server determines what we can see. We don't need to check this. We just display everything that's been given to us.

            var u = _serverInfo.serverInfo.mapUnits;
            for (var _i4 = 0; _i4 < u.length; _i4++) {
                var unit = u[_i4];

                // coordinates do NOT need to be recalculated, as the server already did that for us

                // Determine the UNIQUE label for this unit type => the corresponding drawing should have been preloaded
                // 0 = ship, 1 = monster, 2 = ai ship, 3 = dock
                var label = void 0;
                if (unit.myType == 0) {
                    label = 'shipNum' + unit.index;
                } else if (unit.myType == 1) {
                    label = 'monsterNum' + unit.index;
                } else if (unit.myType == 2) {
                    label = 'aiShipNum' + unit.index;
                } else if (unit.myType == 3) {
                    label = 'dock';
                } else if (unit.myType == 4) {
                    label = 'city';
                }

                var newSprite = canvas.myGame.add.sprite(unit.x * localTileSize, unit.y * localTileSize, label);
                newSprite.width = newSprite.height = localTileSize;
            }

            // move camera to center on our player's ship (by default)
            canvas.myGame.camera.x = Math.floor(0.5 * mapSize) * localTileSize - canvas.myGame.width * 0.5;
            canvas.myGame.camera.y = Math.floor(0.5 * mapSize) * localTileSize - canvas.myGame.height * 0.5;

            // Make it possible to slide across the map (by moving mouse/finger over it)
            canvas.addEventListener('mousedown', startCanvasDrag, false);
            canvas.addEventListener('mouseup', stopCanvasDrag, false);

            // do the same for touch
            canvas.addEventListener('touchstart', startCanvasDrag, false);
            canvas.addEventListener('touchend', stopCanvasDrag, false);

            // Add circular vignet over the image, so it looks like we're watching through binoculars/a telescope
            // This is a png image, with absolute positioning over the canvas, BECAUSE PHASER WOULDN'T LET ME DO IT IN A NORMAL WAY AAAAAAH I HATE MAAAASKS
            var vignetImg = document.createElement("img");
            vignetImg.src = 'assets/cartographerVignet.png';
            vignetImg.style.maxWidth = '100%';
            vignetImg.style.position = 'absolute';
            vignetImg.style.top = 0;
            vignetImg.style.pointerEvents = 'none';

            cont.appendChild(vignetImg);

            break;

        // Sailor: 
        //  => display ship side-view (in background)
        //  => vertical slider for choosing sail strength/height
        //  => horizontal slider for choosing paddle strength
        //  => current sail level + upgrade button
        case 3:
            // Display ship bg (side-view, sails alongside slider)
            var bgShipSide = document.createElement("img");
            bgShipSide.src = "assets/shipGhostSide.png";
            bgShipSide.style.maxWidth = '100%';
            bgShipSide.style.position = 'absolute';
            bgShipSide.style.opacity = 0.5;
            bgShipSide.style.zIndex = -1;

            // TO DO: Do we still want the ghost ship in the background??
            //cont.appendChild(bgShipSide);

            // create CONTAINER for all the sailor stuff
            // we need it, because we're doing complex CSS shit
            var sailorContainer = document.createElement("div");
            sailorContainer.id = 'sailor-container';

            // Determine the change range, based on instrument level
            // Once maxChange becomes 3, we allow it to change 2 per instrument. (Otherwise, we'll never be able to change 3 in one turn.)
            var changeRange = Math.ceil((_serverInfo.serverInfo.roleStats[3].lvl + 1) / 4);

            // Vertical slider for sails
            // Create the actual slider
            var vSlider = document.createElement("input");
            vSlider.type = 'range';
            vSlider.min = -changeRange;
            vSlider.max = changeRange;
            vSlider.value = _serverInfo.serverInfo.roleStats[3].sailLvl - _serverInfo.serverInfo.roleStats[3].oldSailLvl;
            vSlider.id = "sailor-sailInput";

            sailorContainer.appendChild(vSlider);

            // Display numbers next to slider
            var rangeHint00 = document.createElement("div");
            rangeHint00.classList.add("sailor-rangeHintsVertical");
            for (var _i5 = changeRange; _i5 >= -changeRange; _i5--) {
                var tempSpan = document.createElement("span");

                if (_i5 == 0) {
                    tempSpan.innerHTML = '';
                } else {
                    var numSails = _serverInfo.serverInfo.roleStats[3].oldSailLvl + _i5;
                    var tempString = '';
                    for (var a = 0; a < numSails; a++) {
                        tempString += '<img src="assets/sailorIconSails.png" style="margin-left:-30px;" />';
                    }
                    tempSpan.innerHTML = tempString;
                }

                tempSpan.id = 'sailor-sail' + _i5;

                rangeHint00.appendChild(tempSpan);
            }
            sailorContainer.appendChild(rangeHint00);

            // Display crew cost next to slider (move it more to the right of the slider)
            var rangeHint01 = document.createElement("div");
            rangeHint01.classList.add("sailor-rangeHintsVertical");
            rangeHint01.style.left = '55%';

            for (var _i6 = changeRange; _i6 >= -changeRange; _i6--) {
                var _tempSpan = document.createElement("span");

                // determine cost; show it via color (red/green)
                var tempCost = -1;
                if (tempCost > 0) {
                    _tempSpan.style.color = 'lightgreen';
                    tempCost = '+' + tempCost;
                }

                // show cost (number + icon), if not behind speed circle
                if (_i6 != 0) {
                    _tempSpan.innerHTML = tempCost + '<img src="assets/resourceIcon1.png" />';
                }

                _tempSpan.id = 'sailor-sailCost' + _i6;

                rangeHint01.appendChild(_tempSpan);
            }
            sailorContainer.appendChild(rangeHint01);

            // If the slider was changed ...
            // NOTE: "on input" happens immediately after the change, "on change" only when element loses focus
            // We want the latter, because we only send a signal when the user RELEASES the slider. Otherwise, we would send way too many (unnecessary) signals.
            vSlider.addEventListener('change', function () {
                var v = parseInt(this.value);

                var sailRange = _serverInfo.serverInfo.roleStats[3].allowedSailRange;

                // if we go beyond our maximum input, snap back immediately
                if (v < sailRange[0]) {
                    v = sailRange[0];
                    this.value = v;
                } else if (v > sailRange[1]) {
                    v = sailRange[1];
                    this.value = v;
                }

                // get new sail value: it's based on change, so the slider only knows the CHANGE in level, and we need to add the current value
                var newSailValue = _serverInfo.serverInfo.roleStats[3].oldSailLvl + v;

                // if it's the same as our current value, don't do anything
                if (_serverInfo.serverInfo.roleStats[3].sailLvl == newSailValue) {
                    return;
                }

                // ... send the new signal (a sail update)
                socket.emit('sail-up', newSailValue);

                // update personal stats
                _serverInfo.serverInfo.roleStats[3].sailLvl = newSailValue;

                // update speed circle (old speed + change in SAILS + change in PEDDLES)
                _serverInfo.serverInfo.speed = _serverInfo.serverInfo.oldSpeed + (newSailValue - _serverInfo.serverInfo.roleStats[3].oldSailLvl) + (_serverInfo.serverInfo.roleStats[3].peddleLvl - _serverInfo.serverInfo.roleStats[3].oldPeddleLvl);
                document.getElementById('sailor-speedCircle').innerHTML = _serverInfo.serverInfo.speed;

                // update forbidden moves
                disableForbiddenMoves();
            });

            // Horizontal slider for paddles
            // Display the actual slider
            var hSlider = document.createElement("input");
            hSlider.type = 'range';
            hSlider.min = -changeRange;
            hSlider.max = changeRange;
            hSlider.value = _serverInfo.serverInfo.roleStats[3].peddleLvl - _serverInfo.serverInfo.roleStats[3].oldPeddleLvl;
            hSlider.id = 'sailor-peddleInput';

            sailorContainer.appendChild(hSlider);

            // Display numbers underneath slider
            var rangeHint10 = document.createElement("div");
            rangeHint10.classList.add('sailor-rangeHintsHorizontal');
            for (var _i7 = -changeRange; _i7 <= changeRange; _i7++) {
                var _tempSpan2 = document.createElement("span");

                if (_i7 == 0) {
                    _tempSpan2.innerHTML = '';
                } else {
                    var numPeddles = _serverInfo.serverInfo.roleStats[3].oldPeddleLvl + _i7;
                    var _tempString = '';
                    for (var _a = 0; _a < numPeddles; _a++) {
                        if (_a == 0) {
                            // the first one needs no left margin decrease; otherwise it goes out of frame (and generally looks weird)
                            _tempString += '<img src="assets/sailorIconPeddles.png" />';
                        } else {
                            _tempString += '<img src="assets/sailorIconPeddles.png" style="margin-left:-30px;" />';
                        }
                    }
                    _tempSpan2.innerHTML = _tempString;
                }

                _tempSpan2.id = 'sailor-peddle' + _i7;

                rangeHint10.appendChild(_tempSpan2);
            }
            sailorContainer.appendChild(rangeHint10);

            // Display crew cost above slider (and thus change the "top" attribute)
            var rangeHint11 = document.createElement("div");
            rangeHint11.classList.add('sailor-rangeHintsHorizontal');
            rangeHint11.style.top = '32%';
            for (var _i8 = -changeRange; _i8 <= changeRange; _i8++) {
                var _tempSpan3 = document.createElement("span");

                // calculate cost; show it via color (red/green)
                var _tempCost = -2 * _i8;
                if (_tempCost > 0) {
                    _tempSpan3.style.color = 'lightgreen';
                    _tempCost = '+' + _tempCost;
                }

                // display the cost (number + icon), if it's not behind the speed circle
                if (_i8 != 0) {
                    _tempSpan3.innerHTML = _tempCost + '<img src="assets/resourceIcon1.png" />';
                }

                _tempSpan3.id = 'sailor-peddleCost' + _i8;

                rangeHint11.appendChild(_tempSpan3);
            }
            sailorContainer.appendChild(rangeHint11);

            // If the slider has changed ...
            hSlider.addEventListener('change', function () {
                var v = parseInt(this.value);

                var peddleRange = _serverInfo.serverInfo.roleStats[3].allowedPeddleRange;

                // if we go beyond our maximum input, snap back immediately
                if (v < peddleRange[0]) {
                    v = peddleRange[0];
                    this.value = v;
                } else if (v > peddleRange[1]) {
                    v = peddleRange[1];
                    this.value = v;
                }

                // get new peddle value
                var newPeddleValue = _serverInfo.serverInfo.roleStats[3].oldPeddleLvl + v;

                // if it's the same as our current value, don't do anything
                if (_serverInfo.serverInfo.roleStats[3].peddleLvl == newPeddleValue) {
                    return;
                }

                // ... send the new signal (a peddle update)
                socket.emit('peddle-up', newPeddleValue);

                // update personal stats
                _serverInfo.serverInfo.roleStats[3].peddleLvl = newPeddleValue;

                // update speed circle (old speed + change in SAILS + change in PEDDLES)
                _serverInfo.serverInfo.speed = _serverInfo.serverInfo.oldSpeed + (newPeddleValue - _serverInfo.serverInfo.roleStats[3].oldPeddleLvl) + (_serverInfo.serverInfo.roleStats[3].sailLvl - _serverInfo.serverInfo.roleStats[3].oldSailLvl);
                document.getElementById('sailor-speedCircle').innerHTML = _serverInfo.serverInfo.speed;

                // update forbidden moves
                disableForbiddenMoves();
            });

            // Display the large "speed circle" in the center
            var speedCircle = document.createElement("div");
            speedCircle.id = 'sailor-speedCircle';

            // Display the current ship speed
            speedCircle.innerHTML = _serverInfo.serverInfo.speed;

            sailorContainer.appendChild(speedCircle);

            // make the SAILOR container a box that perfectly fits the WIDTH of the screen
            sailorContainer.style.width = cont.offsetWidth + "px";
            sailorContainer.style.height = cont.offsetWidth + "px";

            // add SAILOR container to the overall INTERFACE container (this is getting complex)
            cont.appendChild(sailorContainer);

            // disable all forbidden moves
            // this function is also called every time someone updates the sliders
            disableForbiddenMoves();

            break;

        // Cannoneer:
        //  => display ship (top-view; shows where each cannon is)
        //  => display all cannons (bought or not, current load, loading button)
        case 4:
            // Display ship (top-view, cannons numbered)
            var shipImg = document.createElement("img");
            shipImg.src = "assets/shipGhostTopCannons.png";
            shipImg.style.maxWidth = '100%';

            cont.appendChild(shipImg);

            // Display cannons
            var c = _serverInfo.serverInfo.shipCannons;

            var _loop2 = function _loop2(_i9) {
                // Create new div
                var cannonDiv = document.createElement("div");
                cannonDiv.classList.add("captain-crewMember");

                // Show cannon number
                var span = document.createElement("span");
                span.classList.add("weaponeer-cannonNumber");
                span.innerHTML = _i9 + 1;
                cannonDiv.appendChild(span);

                // If the current load is negative, this cannon hasn't been bought yet
                var curLoad = c[_i9];
                if (curLoad < 0) {
                    // Show "buy" button
                    var buyBtn = document.createElement("button");
                    buyBtn.classList.add('upgradeButton');

                    // Because we're buying, the function calculates the cumulative costs for going to the target level immediately (3rd parameter)
                    buyBtn.innerHTML = loadUpgradeButton(4, 0, _serverInfo.serverInfo.roleStats[4].lvl);
                    buyBtn.style.marginLeft = '40px';

                    cannonDiv.appendChild(buyBtn);

                    // When the button is clicked ...
                    buyBtn.addEventListener('click', function () {
                        // send signal
                        socket.emit('buy-cannon', _i9);

                        // set load to 0 (if its positive, the cannon has been bought)
                        _serverInfo.serverInfo.shipCannons[_i9] = 0;

                        // display a message (to fill space AND to notify the user that he/she did something)
                        var tempParagraph = document.createElement('p');
                        tempParagraph.innerHTML = 'A purchase request has been sent.';
                        cannonDiv.appendChild(tempParagraph);

                        // remove this button
                        this.remove();

                        // don't allow it to load (this turn)
                        _serverInfo.serverInfo.roleStats[4].cannonsLoaded[_i9] = true;
                    });
                } else {
                    // Show the current load ...
                    // ... 1) First load a background
                    var divLoad = document.createElement("div");
                    divLoad.classList.add("weaponeer-cannonLoadBg");
                    cannonDiv.appendChild(divLoad);

                    // ... 2) Then load the amount of guns/bullets/cannon balls on top
                    var spanLoad = document.createElement("span");
                    spanLoad.classList.add("weaponeer-cannonLoad");
                    spanLoad.style.width = curLoad * 10 + 'px';
                    divLoad.appendChild(spanLoad);

                    // If the cannon hasn't been loaded yet, this turn, display the button
                    if (!_serverInfo.serverInfo.roleStats[4].cannonsLoaded[_i9]) {
                        // Show "Load cannon" button
                        var loadBtn = document.createElement("button");
                        loadBtn.innerHTML = 'Load';
                        loadBtn.style.margin = '5px';
                        cannonDiv.appendChild(loadBtn);

                        // When the button is clicked ...
                        loadBtn.addEventListener("click", function () {
                            // send signal
                            socket.emit('load-up', _i9);

                            // update our own load
                            _serverInfo.serverInfo.shipCannons[_i9]++;

                            // remove this button
                            this.remove();

                            // don't allow it to load again (this turn)
                            _serverInfo.serverInfo.roleStats[4].cannonsLoaded[_i9] = true;
                        });
                    }
                }

                cont.appendChild(cannonDiv);
            };

            for (var _i9 = 0; _i9 < c.length; _i9++) {
                _loop2(_i9);
            }

            break;
    }

    // if no upgrade has been submitted yet, display the upgrade button
    // NOTE: the captain (role 0) is the ONLY role without an upgrade button
    // NOTE: All instruments go from level 0 to 5 - never higher, so don't display an upgrade button then
    var nextLevel = _serverInfo.serverInfo.roleStats[num].lvl + 1;
    if (num != 0) {
        // If no upgrade submitted...
        if (!_serverInfo.serverInfo.submittedUpgrade[num]) {
            // If we can still upgrade, display the upgrade button
            if (nextLevel <= 5) {
                var upgradeBtn = document.createElement("button");
                upgradeBtn.classList.add("upgradeButton");

                // load the required resources for the NEXT level of this role 
                upgradeBtn.innerHTML = loadUpgradeButton(num, nextLevel);

                // on click, send upgrade signal, remove this button, display feedback text, remember we've already upgraded
                upgradeBtn.addEventListener('click', function () {
                    socket.emit('upgrade', num);

                    this.remove();
                    document.getElementById('currentLevelStats').remove();
                    _serverInfo.serverInfo.submittedUpgrade[num] = true;

                    var p2 = document.createElement("p");
                    p2.innerHTML = "Upgrade requested. It takes a turn before it's done.";

                    cont.appendChild(p2);
                });

                // add button to container
                cont.appendChild(upgradeBtn);

                // underneath the button, display the stats of the current level, and the level we'd be upgrading towards
                var divLevelStats = document.createElement("div");
                divLevelStats.classList.add("levelStats");
                divLevelStats.id = 'currentLevelStats';

                divLevelStats.innerHTML = displayUpgradeStats(num, _serverInfo.serverInfo.roleStats[num].lvl);

                cont.appendChild(divLevelStats);
            } else {
                // Otherwise, tell the player he's maxed out
                var p0 = document.createElement("p");
                p0.innerHTML = 'You are at maximum level!';

                cont.appendChild(p0);
            }
        } else {
            var p1 = document.createElement("p");
            p1.innerHTML = "Upgrade requested. It takes a turn before it's done.";

            cont.appendChild(p1);
        }
    }
};

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// The upgrade dictionary contains the cost for each upgrade
// The structure is as follows:
//  - Top level = array, index represents role
//     - 2nd level = array, index represents level (you're upgrading TO)
//        - 3rd level = object, key is the resource, value is how many of them are needed

var UPGRADE_DICT = [[], // captain (has no upgrades)
[{}, { 2: 4 }, { 2: 6 }, { 0: 2, 2: 8 }, { 0: 5, 2: 10 }, { 0: 10, 2: 10 }], // first mate
[{}, { 2: 2 }, { 0: 2, 2: 5 }, { 0: 4, 2: 8 }, { 0: 6, 1: 1, 2: 10 }, { 0: 10, 1: 2, 2: 10 }], // cartographer
[{}, { 2: 4 }, { 1: 1, 2: 6 }, { 1: 2, 2: 8 }, { 0: 2, 1: 2, 2: 10 }, { 0: 5, 1: 3, 2: 10 }], // sailor
[{ 0: 5, 1: 1, 2: 10 }, { 2: 4 }, { 1: 1, 2: 7 }, { 0: 5, 2: 10 }, { 0: 5, 1: 1, 2: 10 }, { 0: 10, 1: 2, 2: 10 }] // weapon specialist
];

module.exports = UPGRADE_DICT;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// The upgrade effects dictionary contains the BENEFIT (or EFFECT/RESULT) of each upgrade
// The structure is as follows:
//  - Top level = array, index represents role
//     - 2nd level = array, index represents level (you're upgrading TO)
//        - 3rd level = object, key is the variable/thing being updated, value is to WHAT it's updated

var UPGRADE_EFFECT_DICT = [[], // captain (has no upgrades)
[{ angle: 0 }, { angle: 45 }, { angle: 45 }, { angle: 90 }, { angle: 90 }, { angle: 135 }], // first mate
[{ range: 1, detail: 0 }, { range: 2, detail: 0 }, { range: 3, detail: 0 }, { range: 3, detail: 1 }, { range: 4, detail: 1 }, { range: 5, detail: 2 }], // cartographer
[{ speed: 1, change: 1 }, { speed: 2, change: 1 }, { speed: 3, change: 1 }, { speed: 3, change: 2 }, { speed: 4, change: 2 }, { speed: 5, change: 3 }], // sailor
[{ range: 1, spread: 0 }, { range: 2, spread: 0 }, { range: 2, spread: 1 }, { range: 3, spread: 1 }, { range: 3, spread: 2 }, { range: 4, spread: 2 }] // weapon specialist
];

module.exports = UPGRADE_EFFECT_DICT;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
var CLUE_STRINGS = exports.CLUE_STRINGS = ["They say <strong>@[name]'s treasure</strong> sank in the @[0] ocean", // 0 // deep or shallow
"The <strong>Treasure of @[name]</strong> should be @[0] tiles from the nearest island", // 1 // integer
"<strong>@[name]</strong> hid a treasure somewhere in sector @[0]", // 2 // sector number: 1 up to and including 9
"There are @[0] docks within a @[1] tile radius of <strong>@[name]'s treasure</strong>", // 3 // integer, integer 
"There are @[0] cities within a @[1] tile radius of <strong>@[name]'s treasure</strong>", // 4 // integer, integer 
"There are @[0] unique islands within a @[1] tile radius of <strong>@[name]'s treasure</strong>", // 5 // integer, integer 
"The dock nearest to <strong>@[name]'s treasure</strong> is <em>@[0]</em>", // 6 // dock name
"The island nearest to <strong>@[name]'s treasure</strong> is <em>@[0]</em>", // 7 // island name
"The town nearest to <strong>@[name]'s treasure</strong> is <em>@[0]</em>", // 8 // city name
"<em>@[0]</em> is currently closest to <strong>@[name]'s treasure</strong>!"];

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _serverInfo = __webpack_require__(0);

var _colors = __webpack_require__(1);

var _mainSocketsController = __webpack_require__(6);

var _mainSocketsController2 = _interopRequireDefault(_mainSocketsController);

var _rejoinRoomModule = __webpack_require__(9);

var _rejoinRoomModule2 = _interopRequireDefault(_rejoinRoomModule);

var _roleDictionary = __webpack_require__(7);

var _roleHelpText = __webpack_require__(31);

var _loadTab = __webpack_require__(14);

var _loadTab2 = _interopRequireDefault(_loadTab);

var _timers = __webpack_require__(12);

var _loadErrorMessage = __webpack_require__(15);

var _loadErrorMessage2 = _interopRequireDefault(_loadErrorMessage);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ControllerWaiting = function (_Phaser$State) {
  _inherits(ControllerWaiting, _Phaser$State);

  function ControllerWaiting() {
    _classCallCheck(this, ControllerWaiting);

    return _possibleConstructorReturn(this, (ControllerWaiting.__proto__ || Object.getPrototypeOf(ControllerWaiting)).call(this));
    // construct stuff here, if needed
  }

  _createClass(ControllerWaiting, [{
    key: 'preload',
    value: function preload() {
      // load stuff here, if needed

      // if this player has the cartographer role, preload drawings
      // includes backups for when preparation is skipped
      if (_serverInfo.serverInfo.myRoles.includes(2)) {
        // monsters
        var mDrawings = _serverInfo.serverInfo.monsterDrawings;
        for (var i = 0; i < mDrawings.length; i++) {
          this.game.load.image('monsterNum' + i, mDrawings[i]);
        }

        if (mDrawings.length < 1) {
          this.game.load.image('monsterNum0', _serverInfo.serverInfo.backupMonsterDrawing);
          this.game.load.image('monsterNum1', _serverInfo.serverInfo.backupMonsterDrawing);
          this.game.load.image('monsterNum2', _serverInfo.serverInfo.backupMonsterDrawing);
        }

        // player ships
        var sDrawings = _serverInfo.serverInfo.shipDrawings;
        for (var _i = 0; _i < sDrawings.length; _i++) {
          this.game.load.image('shipNum' + _i, sDrawings[_i]);
        }

        if (sDrawings.length < 1) {
          this.game.load.image('shipNum0', _serverInfo.serverInfo.backupShipDrawing);
          this.game.load.image('shipNum1', _serverInfo.serverInfo.backupShipDrawing);
          this.game.load.image('shipNum2', _serverInfo.serverInfo.backupShipDrawing);
        }

        // ai ships
        var aiDrawings = _serverInfo.serverInfo.aiShipDrawings;
        for (var _i2 = 0; _i2 < aiDrawings.length; _i2++) {
          this.game.load.image('aiShipNum' + _i2, aiDrawings[_i2]);
        }

        if (aiDrawings.length < 1) {
          this.game.load.image('aiShipNum0', _serverInfo.serverInfo.backupShipDrawing);
          this.game.load.image('aiShipNum1', _serverInfo.serverInfo.backupShipDrawing);
          this.game.load.image('aiShipNum2', _serverInfo.serverInfo.backupShipDrawing);
          this.game.load.image('aiShipNum3', _serverInfo.serverInfo.backupShipDrawing);
        }

        // docks
        this.game.load.image('dock', _serverInfo.serverInfo.dockDrawing);
      }
    }
  }, {
    key: 'create',
    value: function create() {
      var gm = this.game;
      var socket = _serverInfo.serverInfo.socket;

      var curTab = { num: 0 };

      var div = document.getElementById("main-controller");
      var ths = this; // for referencing the original "this" object within eventListeners

      /**** 
          DO SOME EXTRA INITIALIZATION 
        *****/
      // TO DO: This could be much simpler. No need to go through all the roles; just initialize everything to zero.
      // loop through all the roles
      var roles = _serverInfo.serverInfo.myRoles;
      for (var i = 0; i < roles.length; i++) {
        var roleNum = roles[i];
        switch (roleNum) {
          // Captain needs to listen to resource changes
          case 0:
            // res-up => resource update
            socket.on('res-up', function (data) {
              // save the received resources
              _serverInfo.serverInfo.resources = data;

              // if the captain tab is currently displaying, update it
              if (curTab.num == 0) {
                for (var _i3 = 0; _i3 < data.length; _i3++) {
                  document.getElementById('shipResource' + _i3).innerHTML = data[_i3];
                }
              }
            });

            // error-msg => error message (because another crew member screwed up)
            socket.on('error-msg', function (msg) {
              _serverInfo.serverInfo.errorMessages.push(msg);

              // if the captain tab is currently displaying, update it with the new error
              if (curTab.num == 0) {
                document.getElementById('captain-errorMessageContainer').appendChild((0, _loadErrorMessage2.default)(_serverInfo.serverInfo.errorMessages.length - 1));
              }
            });

            break;

          // First mate
          // Set compass level to 0; set (and save) orientation
          case 1:
            _serverInfo.serverInfo.roleStats[1].lvl = 0;

            _serverInfo.serverInfo.oldOrientation = 0;
            _serverInfo.serverInfo.orientation = 0;

            break;

          // Cartographer
          // Set map/telescope level to 0
          case 2:
            _serverInfo.serverInfo.roleStats[2].lvl = 0;

            break;

          // Sailor
          // Set instrument level to 0
          case 3:
            _serverInfo.serverInfo.roleStats[3].lvl = 0;
            _serverInfo.serverInfo.roleStats[3].sailLvl = 0;
            _serverInfo.serverInfo.roleStats[3].peddleLvl = 0;

            _serverInfo.serverInfo.roleStats[3].oldSailLvl = 0;
            _serverInfo.serverInfo.roleStats[3].oldPeddleLvl = 0;

            _serverInfo.serverInfo.speed = 0;
            _serverInfo.serverInfo.oldSpeed = 0;

            break;

          // Cannoneer
          // Set cannon level to 0
          case 4:
            _serverInfo.serverInfo.roleStats[4].lvl = 0;

            // Also, create variable that checks if cannon has already been loaded
            _serverInfo.serverInfo.roleStats[4].cannonsLoaded = {};

            break;
        }
      }

      /**** 
          DISPLAY INTERFACE 
        *****/

      // Add the "help" overlay (and event listener to close it)
      var helpOverlay = document.createElement("div");
      helpOverlay.classList.add("helpOverlay");

      helpOverlay.addEventListener('click', function (ev) {
        helpOverlay.style.display = 'none';
      }, false);

      div.appendChild(helpOverlay);

      // Add the health bar at the top
      var healthBar = document.createElement("div");
      healthBar.id = "healthBar";
      healthBar.classList.add('shipColor' + _serverInfo.serverInfo.myShip); // set bar to the right color
      div.appendChild(healthBar);

      // Add the ship info (name + flag)
      var shipInfo = document.createElement("div");
      shipInfo.id = 'shipInfo';
      shipInfo.innerHTML = '<img src="' + _serverInfo.serverInfo.shipFlag + '" />' + _serverInfo.serverInfo.shipTitle;
      shipInfo.classList.add('shipColor' + _serverInfo.serverInfo.myShip); // set font to the right color
      div.appendChild(shipInfo);

      // Add the help button (which will trigger the helpOverlay)
      var helpButton = document.createElement("div");
      helpButton.innerHTML = '?';
      helpButton.classList.add('helpButton');

      // On clicking the help button, an overlay appears with help text
      helpButton.addEventListener('click', function () {
        // make overlay visible
        helpOverlay.style.display = 'block';

        // fill it with the right text (based on current role tab)
        helpOverlay.innerHTML = _roleHelpText.ROLE_HELP_TEXT[curTab.num];

        // the overlay itself has an event listener for closing it
      }, false);

      div.appendChild(helpButton);

      // Add the tabs for switching roles
      // first create the container
      var shipRoles = document.createElement("div");
      shipRoles.id = 'shipRoles';

      // then add the roles
      //let roles = serverInfo.myRoles;
      for (var _i4 = 0; _i4 < roles.length; _i4++) {
        var _roleNum = roles[_i4];

        // create a new tab object (with correct/unique label and z-index)
        var newTab = document.createElement("span");
        newTab.classList.add("shipRoleGroup");
        newTab.id = 'label' + _i4;
        newTab.style.zIndex = 5 - _i4;

        // add the ICON and the ROLE NAME within the tab
        newTab.innerHTML = '<img src="assets/roleIcon' + _roleNum + '.png"/><span class="shipRoleTitle">' + _roleDictionary.ROLE_DICTIONARY[_roleNum] + '</span>';

        // when you click this tab, unload the previous tab, and load the new one!
        // REMEMBER: "this" is the object associated with the event listener, "ev.target" is the thing that was actually clicked
        newTab.addEventListener('click', function (ev) {
          ev.preventDefault();
          (0, _loadTab2.default)(this.id, curTab, 1);
        });

        shipRoles.appendChild(newTab);
      }

      // finally, add the whole thing to the page
      div.appendChild(shipRoles);

      // add the area for the role interface
      var shipInterface = document.createElement("div");
      shipInterface.id = 'shipInterface';
      div.appendChild(shipInterface);

      // automatically load the first role 
      // (by calling LOAD_TAB with value 0; third parameter loads play interface instead of prep interface)
      (0, _loadTab2.default)("label0", curTab, 1);

      // The first turn is always twice as long!
      this.timer = _serverInfo.serverInfo.timer * 2;

      (0, _mainSocketsController2.default)(socket, gm, _serverInfo.serverInfo);

      console.log("Controller Play state");

      /**** 
          LISTEN FOR "NEW TURN" SIGNALS
        *****/

      // Function that is called whenever a new turn starts
      // Resets timer, cleans interface variables, reloads first tab
      // This is called AFTER the pre-signal that sets all sorts of information
      socket.on('new-turn', function (data) {
        console.log("New turn => resetting timer to " + _serverInfo.serverInfo.timer);

        // reset the timer (if you're the VIP)
        if (_serverInfo.serverInfo.vip) {
          ths.timer = _serverInfo.serverInfo.timer;
        }

        // clean interface variables
        // errorMessages are "cleaned" by the server sending a new array, which might be empty
        _serverInfo.serverInfo.submittedUpgrade = {};
        _serverInfo.serverInfo.roleStats[4].cannonsLoaded = {};

        // save orientation, so you can play with it without the ghost ship changing
        _serverInfo.serverInfo.oldOrientation = _serverInfo.serverInfo.orientation;

        // save old speed, sail and peddle level
        // so we can change it during the turn without lasting effects
        _serverInfo.serverInfo.oldSpeed = _serverInfo.serverInfo.speed;
        _serverInfo.serverInfo.roleStats[3].oldSailLvl = _serverInfo.serverInfo.roleStats[3].sailLvl;
        _serverInfo.serverInfo.roleStats[3].oldPeddleLvl = _serverInfo.serverInfo.roleStats[3].peddleLvl;

        // update ship health
        document.getElementById('healthBar').style.width = _serverInfo.serverInfo.health + '%';

        // switch to day/night if necessary
        _serverInfo.serverInfo.turnCount++;
        if (_serverInfo.serverInfo.turnCount % 10 == 0) {
          _serverInfo.serverInfo.dayTime = !_serverInfo.serverInfo.dayTime;

          // TO DO
          // Do something with the fact that it's now night?
        }

        // reload first tab
        (0, _loadTab2.default)("label0", curTab, 1);
      });
    }
  }, {
    key: 'update',
    value: function update() {
      // Update timer
      (0, _timers.controllerTimer)(this, _serverInfo.serverInfo);
    }
  }]);

  return ControllerWaiting;
}(Phaser.State);

exports.default = ControllerWaiting;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
var ROLE_HELP_TEXT = exports.ROLE_HELP_TEXT = [
// Captain
"<p>The <strong>Captain</strong> makes the most important decisions on the ship. He's also the only one who can see the 4 basic resources: crew, gold, wood, treasure.</p>\
    <p>His most important decision is whether to fight ( = fire all the cannons). He can also discover new islands, trade resources with a dock, and more.</p>\
    <p>The captain is the only role that can't be upgraded</p>",

// First Mate
"<p>The <strong>First Mate</strong> steers the ship by rotating the compass towards the desired direction.</p>\
    <p>The ship in the background reminds you of last turn's orientation.</p>\
    <p>At the start, you can't rotate the compass. By upgrading, you get more freedom of movement. The red circle indicates angles you can NOT choose.</p>",

// Cartographer
"<p>The <strong>Cartographer</strong> is the only one who can read the map (and has to find out where the ship is)</p>\
	<p>By sliding/dragging your finger, you can move around the map.</p>\
	<p>At the start, you can only see a small area around you. By upgrading, your sight improves: you can see further and get more details about surrounding units.</p>\
	<p>TIP: Constantly tell the others what's happening. The First Mate and Sailor cannot sail blind - they depend on you!</p>",

// Sailor
"<p>The <strong>Sailor</strong> determines the speed of the ship. He can adjust the sails or make crew row the boat.</p>\
	<p>Adjusting the sails is a one-time action: you spend X crew to quickly change the sail.</p>\
	<p>Rowing is continuous: once you spend X crew on rowing, they will keep rowing until you tell them to stop.</p>\
	<p>At the start, the ship has a small maximum speed and maximum change (acceleration/deceleration). By upgrading, you can raise this ceiling.</p>"];

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _serverInfo = __webpack_require__(0);

var _colors = __webpack_require__(1);

var _mainSocketsController = __webpack_require__(6);

var _mainSocketsController2 = _interopRequireDefault(_mainSocketsController);

var _rejoinRoomModule = __webpack_require__(9);

var _rejoinRoomModule2 = _interopRequireDefault(_rejoinRoomModule);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ControllerWaiting = function (_Phaser$State) {
  _inherits(ControllerWaiting, _Phaser$State);

  function ControllerWaiting() {
    _classCallCheck(this, ControllerWaiting);

    return _possibleConstructorReturn(this, (ControllerWaiting.__proto__ || Object.getPrototypeOf(ControllerWaiting)).call(this));
    // construct stuff here, if needed
  }

  _createClass(ControllerWaiting, [{
    key: 'preload',
    value: function preload() {
      // load stuff here, if needed
    }
  }, {
    key: 'create',
    value: function create() {
      var gm = this.game;
      var socket = _serverInfo.serverInfo.socket;

      var div = document.getElementById("main-controller");

      // Create some text to explain rejoining was succesfull. 
      // If the player was already done for this round, the function returns true, and we stop loading the interface
      // TO DO: At the moment, rejoining in the waiting room is actually forbidden. (Also, it doesn't load the main sockets now.) Fix this sometime.
      if ((0, _rejoinRoomModule2.default)(socket, _serverInfo.serverInfo, div)) {
        return;
      }

      // display VIP message
      // and start button
      if (_serverInfo.serverInfo.vip) {
        var p2 = document.createElement("p");
        p2.innerHTML = _serverInfo.serverInfo.translate("vip-message-waiting");
        div.appendChild(p2);

        var btn1 = document.createElement("button");
        btn1.innerHTML = _serverInfo.serverInfo.translate("start-game");
        btn1.addEventListener('click', function (event) {
          if (btn1.disabled) {
            return;
          }

          btn1.disabled = true;

          // send message to server that we want to start
          socket.emit('start-game', {});

          // we don't need to go to the next state; that happens automatically when the server responds with "okay! we start!"
        });
        div.appendChild(btn1);
      }

      // ask user to draw their own profile pic
      var p3 = document.createElement("p");
      p3.innerHTML = _serverInfo.serverInfo.translate('controller-waiting-1');
      div.appendChild(p3);

      // move canvas inside GUI
      var canvas = document.getElementById("canvas-container");
      div.appendChild(canvas);

      // make canvas the correct size
      // check what's the maximum width or height we can use
      var maxWidth = document.getElementById('main-controller').clientWidth;
      // calculate height of the viewport, subtract the space lost because of text above the canvas, subtract space lost from button (height+padding+margin)
      var maxHeight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0) - canvas.getBoundingClientRect().top - (16 + 8 * 2 + 4 * 2);
      // determine the greatest width we can use (either the original width, or the width that will lead to maximum allowed height)
      var finalWidth = Math.min(maxWidth, maxHeight / 1.3);
      // scale the game immediately (both stage and canvas simultaneously)
      gm.scale.setGameSize(finalWidth, finalWidth * 1.3);

      // add a bitmap for drawing
      this.bmd = gm.add.bitmapData(gm.width, gm.height);
      this.bmd.ctx.strokeStyle = _colors.playerColors[_serverInfo.serverInfo.rank]; // THIS is the actual drawing color      
      this.bmd.ctx.lineWidth = 10;
      this.bmd.ctx.lineCap = 'round';
      this.bmd.ctx.fillStyle = '#ff0000';
      this.sprite = gm.add.sprite(0, 0, this.bmd);
      this.bmd.isDragging = false;
      this.bmd.lastPoint = null;
      //this.bmd.smoothed = false;
      var bmdReference = this.bmd;

      // display button to submit drawing
      var btn2 = document.createElement("button");
      btn2.innerHTML = _serverInfo.serverInfo.translate("submit-drawing");
      btn2.addEventListener('click', function (event) {
        var dataURI = bmdReference.canvas.toDataURL();

        // send the drawing to the server (including the information that it's a profile pic)
        socket.emit('submit-drawing', { dataURI: dataURI, type: "profile" });

        // Remove submit button
        btn2.remove();

        // Disable canvas
        canvas.style.display = 'none';

        if (!_serverInfo.serverInfo.vip) {
          p3.innerHTML = _serverInfo.serverInfo.translate('controller-waiting-2');
        } else {
          p3.innerHTML = '';
        }
      });
      div.appendChild(btn2);

      (0, _mainSocketsController2.default)(socket, gm, _serverInfo.serverInfo);

      console.log("Controller Waiting state");
    }
  }, {
    key: 'update',
    value: function update() {
      // This is where we listen for input!

      /***
       * DRAW STUFF
       ***/
      if (this.game.input.activePointer.isUp) {
        this.bmd.isDragging = false;
        this.bmd.lastPoint = null;
      }

      if (this.game.input.activePointer.isDown) {
        this.bmd.isDragging = true;
        this.bmd.ctx.beginPath();
        var newPoint = new Phaser.Point(this.game.input.x, this.game.input.y);

        if (this.bmd.lastPoint) {
          this.bmd.ctx.moveTo(this.bmd.lastPoint.x, this.bmd.lastPoint.y);
          this.bmd.ctx.lineTo(newPoint.x, newPoint.y);
        }

        this.bmd.lastPoint = newPoint;
        this.bmd.ctx.stroke();

        this.bmd.dirty = true;
      }
    }
  }]);

  return ControllerWaiting;
}(Phaser.State);

exports.default = ControllerWaiting;

/***/ })
/******/ ]);